/* autogenerated by Processing revision 1293 on 2024-01-19 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import processing.net.*;
import garciadelcastillo.dashedlines.*;
import static javax.swing.JOptionPane.*;
import java.awt.Dimension;
import java.awt.FlowLayout;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;


import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.Frame;
import processing.awt.PSurfaceAWT;
import processing.awt.PSurfaceAWT.SmoothCanvas;



import http.requests.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import processing.data.JSONObject;
import processing.data.JSONArray;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Clipboard;
import java.awt.Toolkit;


class OllamaSettings extends JFrame {
    JComboBox<String> modelComboBox;
    JSpinner maxTokensSpinner;
    JSlider temperatureSlider, topPSlider, frequencyPenaltySlider, presencePenaltySlider;

    String selectedModel = "llama3.2";
    int maxTokens = 50;
    double temperature = 0.7;
    double topP = 0.9;
    double frequencyPenalty = 0.5;
    double presencePenalty = 0.6;

    public OllamaSettings(OllamaWindow ollamaWindow) {
        setTitle("Impostazioni IA");
        setSize(500, 700); // Aumenta la dimensione della finestra
        setLayout(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(10, 10, 10, 10); // Offset tra componenti
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Modello
        modelComboBox = new JComboBox<>();
        populateModels(); // Popola i modelli disponibili
        modelComboBox.addActionListener(e -> selectedModel = (String) modelComboBox.getSelectedItem());

        gbc.gridx = 0; gbc.gridy = 0; gbc.gridwidth = 2;
        add(new JLabel("Modello:"), gbc);
        gbc.gridy++;
        gbc.gridwidth = 2;
        add(modelComboBox, gbc);

        // Max Tokens
        maxTokensSpinner = new JSpinner(new SpinnerNumberModel(maxTokens, 1, 200, 1));
        maxTokensSpinner.addChangeListener(e -> maxTokens = (int) maxTokensSpinner.getValue());

        gbc.gridx = 0; gbc.gridy++; gbc.gridwidth = 1;
        add(new JLabel("Max Tokens (Lunghezza del testo generato):"), gbc);
        gbc.gridx = 1;
        add(maxTokensSpinner, gbc);

        // Temperature
        temperatureSlider = new JSlider(0, 100, (int) (temperature * 100));
        temperatureSlider.addChangeListener(e -> temperature = temperatureSlider.getValue() / 100.0);

        gbc.gridx = 0; gbc.gridy++; gbc.gridwidth = 1;
        add(new JLabel("Temperature (Casualità nella generazione):"), gbc);
        gbc.gridx = 1;
        add(temperatureSlider, gbc);

        // Top P
        topPSlider = new JSlider(0, 100, (int) (topP * 100));
        topPSlider.addChangeListener(e -> topP = topPSlider.getValue() / 100.0);

        gbc.gridx = 0; gbc.gridy++; gbc.gridwidth = 1;
        add(new JLabel("Top P (Controlla la varietà di parole):"), gbc);
        gbc.gridx = 1;
        add(topPSlider, gbc);

        // Frequency Penalty
        frequencyPenaltySlider = new JSlider(0, 100, (int) (frequencyPenalty * 100));
        frequencyPenaltySlider.addChangeListener(e -> frequencyPenalty = frequencyPenaltySlider.getValue() / 100.0);

        gbc.gridx = 0; gbc.gridy++; gbc.gridwidth = 1;
        add(new JLabel("Frequency Penalty (Penalità per ripetizione di parole):"), gbc);
        gbc.gridx = 1;
        add(frequencyPenaltySlider, gbc);

        // Presence Penalty
        presencePenaltySlider = new JSlider(0, 100, (int) (presencePenalty * 100));
        presencePenaltySlider.addChangeListener(e -> presencePenalty = presencePenaltySlider.getValue() / 100.0);

        gbc.gridx = 0; gbc.gridy++; gbc.gridwidth = 1;
        add(new JLabel("Presence Penalty (Penalità per presenza di parole):"), gbc);
        gbc.gridx = 1;
        add(presencePenaltySlider, gbc);

        // Pulsante Applica
        JButton applyButton = new JButton("Applica");
        applyButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                ollamaWindow.updateParameters(selectedModel, maxTokens, temperature, topP, frequencyPenalty, presencePenalty);
                JOptionPane.showMessageDialog(null, "Parametri aggiornati!");
            }
        });

        gbc.gridx = 0; gbc.gridy++; gbc.gridwidth = 2;
        gbc.anchor = GridBagConstraints.CENTER; // Centra il pulsante
        add(applyButton, gbc);
    }

    // Funzione per ottenere i modelli disponibili
    void populateModels() {
        try {
            // Richiesta dei modelli a Ollama usando l'endpoint corretto
            GetRequest get = new GetRequest("http://localhost:11434/api/tags");
            get.send();
            String response = get.getContent();  // Ottieni il contenuto come stringa

            // Parsing JSON come JSONObject per accedere al campo "models"
            JSONObject jsonResponse = JSONObject.parse(response);
            JSONArray modelsArray = jsonResponse.getJSONArray("models");

            // Rimuovi elementi precedenti dal menu a tendina
            modelComboBox.removeAllItems();

            // Itera attraverso l'array di modelli e aggiungi i nomi al menu
            for (int i = 0; i < modelsArray.size(); i++) {
                JSONObject model = modelsArray.getJSONObject(i);
                String modelName = model.getString("name");
                modelComboBox.addItem(modelName);
            }

            // Seleziona il primo modello di default, se disponibile
            if (modelComboBox.getItemCount() > 0) {
                selectedModel = (String) modelComboBox.getItemAt(0);
            }

        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Errore durante la richiesta dei modelli: " + e.getMessage());
        }
    }
}


class OllamaWindow extends JPanel {
    JTextArea responseArea;
    JTextField promptField;
    JButton sendButton;
    JButton resetButton;
    JButton settingsButton;
    JButton copyButton;  // Nuovo pulsante per copiare negli appunti

    // Parametri di default
    String model = "llama3.2";
    int maxTokens = 50;
    double temperature = 0.7;
    double topP = 0.9;
    double frequencyPenalty = 0.5;
    double presencePenalty = 0.6;

    public OllamaWindow() {
        setLayout(new BorderLayout());
        createSwingUI();
    }
    private OllamaSettings settingsWindow;

    // Crea l'interfaccia utente Swing
    void createSwingUI() {
        Font customFont = new Font("SansSerif", Font.PLAIN, 20); // Font personalizzato con dimensione maggiore

        // Campo di input per il prompt
        promptField = new JTextField();
        promptField.setFont(customFont);
        promptField.setPreferredSize(new Dimension(700, 30));
        add(promptField, BorderLayout.NORTH);

        // Area di testo per la risposta
        responseArea = new JTextArea();
        responseArea.setFont(customFont);
        responseArea.setEditable(false);
        responseArea.setLineWrap(true);
        responseArea.setWrapStyleWord(true);
        responseArea.setMargin(new Insets(20, 20, 20, 20));  // Aggiunge margini interni di 10 px su ogni lato
        add(new JScrollPane(responseArea), BorderLayout.CENTER);

        // Pannello per i pulsanti
        JPanel buttonPanel = new JPanel();
        sendButton = new JButton("Invia");
        resetButton = new JButton("Reset");
        settingsButton = new JButton("Impostazioni IA"); // Pulsante per aprire le impostazioni
        copyButton = new JButton("Copia negli Appunti");  // Nuovo pulsante
        sendButton.setFont(customFont);
        resetButton.setFont(customFont);
        settingsButton.setFont(customFont);
        copyButton.setFont(customFont);

        // Imposta il font e la dimensione preferita per tutti i pulsanti
        Dimension buttonSize = new Dimension(180, 40);
        sendButton.setPreferredSize(buttonSize);
        resetButton.setPreferredSize(buttonSize);
        settingsButton.setPreferredSize(buttonSize);
        copyButton.setPreferredSize(buttonSize);

        // Colore blu per il pulsante "Copia negli Appunti"
        copyButton.setBackground(new Color(0, 122, 255));  // Blu
        copyButton.setForeground(Color.WHITE);  // Testo bianco

        buttonPanel.add(sendButton);
        buttonPanel.add(resetButton);
        buttonPanel.add(settingsButton);
        buttonPanel.add(copyButton);
        add(buttonPanel, BorderLayout.SOUTH);

        // Aggiungi azioni ai pulsanti
        sendButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                responseArea.setText("Invio della richiesta...");
                new Thread(() -> sendPrompt()).start();  // Esegui la richiesta in un nuovo thread
            }
        });

        resetButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                promptField.setText("");
                responseArea.setText("");
            }
        });

       settingsButton.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
        if (settingsWindow == null || !settingsWindow.isDisplayable()) {
            settingsWindow = new OllamaSettings(OllamaWindow.this);
            settingsWindow.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            settingsWindow.setVisible(true);
        } else {
            settingsWindow.toFront(); // Porta la finestra già aperta in primo piano
        }
    }
});


        // Azione per il pulsante "Copia negli Appunti"
        copyButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                String responseText = responseArea.getText();
                if (!responseText.isEmpty()) {
                    StringSelection selection = new StringSelection(responseText);
                    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection, null);
                    JOptionPane.showMessageDialog(null, "Risposta copiata negli appunti!");
                } else {
                    JOptionPane.showMessageDialog(null, "Non c'è nulla da copiare!");
                }
            }
        });
    }

    // Metodo per aggiornare i parametri dai valori delle impostazioni
    public void updateParameters(String model, int maxTokens, double temperature, double topP, double frequencyPenalty, double presencePenalty) {
        this.model = model;
        this.maxTokens = maxTokens;
        this.temperature = temperature;
        this.topP = topP;
        this.frequencyPenalty = frequencyPenalty;
        this.presencePenalty = presencePenalty;
    }

    // Funzione per inviare il prompt a Ollama
    void sendPrompt() {
        try {
            PostRequest post = new PostRequest("http://localhost:11434/api/generate");
            post.addHeader("Content-Type", "application/json");

            // Crea il JSON con il prompt dell'utente e i parametri
            String userPrompt = promptField.getText();
            String jsonPrompt = "{ " +
                "\"model\": \"" + model + "\"," +
                "\"prompt\": \"" + userPrompt + "\"," +
                "\"max_tokens\": " + maxTokens + "," +
                "\"temperature\": " + temperature + "," +
                "\"top_p\": " + topP + "," +
                "\"frequency_penalty\": " + frequencyPenalty + "," +
                "\"presence_penalty\": " + presencePenalty + "," +
                "\"stream\": false," +
                "\"stop\": [\"\\n\", \"END\"]" +
            "}";

            post.addData(jsonPrompt);
            post.send();

            // Recupera il contenuto come stringa
            String content = post.getContent();

            // Parsing della risposta JSON utilizzando processing.data.JSONObject
            SwingUtilities.invokeLater(() -> {
                try {
                    JSONObject json = JSONObject.parse(content);  // Parsing della risposta JSON
                    String responseText = json.getString("response");
                    responseArea.setText(responseText);
                } catch (Exception e) {
                    responseArea.setText("Errore durante il parsing della risposta");
                }
            });
        } catch (Exception ex) {
            SwingUtilities.invokeLater(() -> responseArea.setText("Errore durante la richiesta: " + ex.getMessage()));
        }
    }
}

public class sketch_Storygraphia_09_7 extends PApplet {



 // library for dashed lines 
 // library for text input 






OllamaWindow ollamaWindow;
JFrame frame;


String storygraphia_license = "credits: Vincenzo Lombardo, released under GNU General Public License version 3";
String graph_name = "NULL";
PImage sg_logo, sg_menu, twine_logo, ollama_logo;
String[] plot_generation_modes = {"MANUAL","PAINTING","SCULPTING","TENSION","PROPP"};

// ----------- SETTINGS ----------
public void settings() {  
  generic_layout_settings(); // LAYOUT 
  help_settings(); // HELP LAYOUT
  generic_graph_settings(); // GRAPH
  // SPECIFIC SETTINGS
  unit_settings();
  agents_settings();
  tags_settings();
  // propp_settings();
  states_settings();
  tensions_settings();

  sg_logo = loadImage("SG_logo_trasp.png"); // 308x202  
  twine_logo = loadImage("Twine_logo_trasp.png"); // 320x322  
  ollama_logo = loadImage ("Ollama.png");
  sg_button = new imgButton(sg_logo, "Reset narrative! Unsaved changes will be lost.", (left_offset/2)/zoom-xo, (top_offset/2)/zoom-yo, left_offset, top_offset);
  twine_button = new imgButton(twine_logo, "Export to Twine (basic Harlowe format)", (1.5f*left_offset)/zoom-xo, (top_offset/2)/zoom-yo, left_offset, top_offset);
  ollama_button = new imgButton(ollama_logo, "Invoca Ollama!!!", (2.25f*left_offset)/zoom-xo, (top_offset/2)/zoom-yo, left_offset, top_offset);
  sg_menu = loadImage("Storygraphia_menu.png"); // 720x405
}

// ----------- SETUP ----------
public void setup() { 
  // GENERIC SETUPS
  text_setup(); // text settings
  color_setup(); 
  // Initialize dashed lines, passing a reference to the current PApplet
  dash = new DashedLines(this);
  // Set the dash-gap pattern in pixels
  dash.pattern(10, 5);

  initial_page_setup(); 
  nav_edt_setup(); 
  man_prp_ptg_tns_setup(); 
  // SPECIFIC SETUPS
  generic_graph_setup();
  story_specific_setup();
  // menu_checkbox_setup();
} // end setup

// ----------- DRAW ----------
public void draw() {
  background(0, 0, 100); // white background
  stroke(edge_color); 
  fill(node_color); 
  rectMode(CENTER); 
  // draw_agents(); draw_tags();
  if (!graph_name.equals("NULL")) {draw_header(); draw_footer();} // this makes graphics stable

  pushMatrix();
  translate (xo, yo);
  scale (zoom);
  // if (plot_generation_mode.equals("PROPP")) {propp_layout_bg_matrix();} // Propp background 
  // initialization 
  switch(modality) {
  case "INI": // *********** INITIALIZATION *************
    storygraphia_license_setup();
    initialization_choice(); 
    break;      
  case "PRP": // *********** LAYOUT PREPARATION ************* 
    modality="EDT"; nav_edt_button.text = "EDT";
    if (plot_generation_mode.equals("PAINTING")) {man_prp_ptg_tns_switch_button.text=ptg_text;} // || plot_generation_mode.equals("SCULPTING")
    else if (plot_generation_mode.equals("TENSION")) {man_prp_ptg_tns_switch_button.text=tns_text; tension_bg_setup();} 
    else if (plot_generation_mode.equals("PROPP")) {man_prp_ptg_tns_switch_button.text=prp_text;}  
    else {man_prp_ptg_tns_switch_button.text=man_text;} // (MANUAL) 
    break;      
  // =============================================================
  // ========================= EDT ===============================
  // =============================================================
  case "EDT": // *********** EDITING *************
    // DRAWING
    // *** background
    if (plot_generation_mode.equals("PAINTING") || plot_generation_mode.equals("SCULPTING")) {constraints_layout_bg();} // Pre-effs background 
    else if (plot_generation_mode.equals("TENSION")) {tension_layout_bg();} // Tension arc background
    else if (plot_generation_mode.equals("PROPP")) {propp_layout_bg_matrix(); draw_propp_functions();} // Propp background 
    else {background(0, 0, 100);} // (MANUAL) white background
    if (white_page) {
      flex_write_lines_in_box("Press 'h' for help", default_font_name, default_font_aspect_ratio, 
                              "CENTER", "CENTER", width/2-xo, height-bottom_offset-yo, width-left_offset*2, y_credits);
    }
    draw_agents(); draw_tags(); draw_header(); draw_footer();
    if (plot_generation_mode.equals("PAINTING") || plot_generation_mode.equals("SCULPTING")) {draw_states(); state_layover();} // draw states the mode is PRE-EFFs
    else if (plot_generation_mode.equals("TENSION")) {draw_tensions(); tension_layover();} // draw states the mode is TENSION
    else if (plot_generation_mode.equals("PROPP")) {draw_propp_functions(); pf_layover();} // draw states the mode is PROPP
    // *** header
    // if (!graph_name.equals("NULL")) {draw_header();}
    // *** draw edges
    draw_labelled_edges();
    // *** draw nodes
    for (int i=0; i<i_cur_node; i++) {
      Unit u = (Unit) nodes[i]; 
      u.draw_unit();
    } 
    if (!select_type.equals("NULL")) {story_show_menus();} 
    // *** layover
    else {layover(); agent_layover(); tag_layover(); button_layover();} 
    if (help_b) {display_help();}
    break;
  // =============================================================
  // ======================= NAV =================================
  // =============================================================
  case "NAV": // *********** NAVIGATING THE GRAPH *************
    draw_agents(); draw_tags(); 
    // *** header
    if (!graph_name.equals("NULL")) {draw_header();}
    // set the cur_nav_unit
    next_node_in_nav();
    // find predecessor and subsequent units
    // set positions for adjacent unit and related edges
    // *** draw edges
    Unit u_cur = (Unit) nodes[cur_nav_node_index];
    for (int i=0; i<i_cur_edge; i++) {
      if (searchStringIndex(plot_generation_mode, edges[i].pg_modes, 0, edges[i].pg_modes.length)!=-1 &&
          ((searchStringIndex(edges[i].tail_id, predecessor_node_ids, 0, i_cur_predecessor)!=-1 && 
          edges[i].head_id.equals(u_cur.id)) ||
          (searchStringIndex(edges[i].head_id, subsequent_node_ids, 0, i_cur_subsequent)!=-1 && 
          edges[i].tail_id.equals(u_cur.id))))
          {
        edges[i].draw_labelled_edge(); 
      }
    }; 
    // draw unit and edges
    for (int i=0; i<i_cur_node; i++) {
      Unit u = (Unit) nodes[i]; 
      if (i == cur_nav_node_index) {u.draw_unit_in_nav("cur");}
      else if (searchStringIndex(u.id, predecessor_node_ids, 0, i_cur_predecessor)!=-1) {
        u.draw_unit_in_nav("pre");}
      else if (searchStringIndex(u.id, subsequent_node_ids, 0, i_cur_subsequent)!=-1) {
        u.draw_unit_in_nav("sub");}
    } 
    // *** layover
    layover_nav(); agent_layover(); tag_layover(); // button_layover();
    break;
  } // end SWITCH
  popMatrix();
} // end draw



// *** STORY SPECIFIC INTERACTIVITY

public void mouseClicked() {
  switch(modality) {
  case "INI": 
    story_initialization_go();
    break;
  case "EDT":
    // if mouse in the central editing area
    // if (mouseX < width-right_offset && mouseY > top_offset &&
       // mouseX > left_offset && mouseY < height) {
    // node selection (always possible)
    node_selection(); 
    // edge selection (not possible with SCULPTING and PAINTING)
    // if (plot_generation_mode.equals("MANUAL") || plot_generation_mode.equals("TENSION") || plot_generation_mode.equals("PROPP"))
      edge_selection();
    //} else
    // if mouse in the agent area
    // if (mouseX < left_offset && mouseY > top_offset &&
       // mouseX > 0 && mouseY < height) {
    // agent selection (always possible)
    agent_selection();
    // } else
    // if mouse in the tag area
    // if (mouseX < width && mouseY > top_offset &&
       // mouseX > width-right_offset && mouseY < height) {
    // tag selection (always possible)
    tag_selection();
    //} else
    // if mouse in the state area
    // if (mouseX < width && mouseY > height - bottom_offset &&
       //  mouseX > left_offset && mouseY < height) {
    // Propp function selection (only possible in PROPP mode)
    if (plot_generation_mode.equals("PROPP")) {pf_selection();}
    // tension selection (only possible in TENSION mode)
    else if (plot_generation_mode.equals("TENSION")) {tension_selection();} 
    // state selection (only possible in PAINTING and SCULPTING modes)
    else if (plot_generation_mode.equals("PAINTING") || plot_generation_mode.equals("SCULPTING")) {state_selection();}      
    // NAV/EDT button click (always possible)
    if (nav_edt_button.click_rectButton() && i_cur_node > 0) {nav_edt_go();} else
    // MAN/PRP/PTG/TNS button click (in EDT mode)
    if (man_prp_ptg_tns_switch_button.click_rectButton() && i_cur_node > 0) {man_prp_ptg_tns_go();} else
    // Twine export button click (always possible)
    if (ollama_button.click_imgButton()) {ollama_button_go();} else
    if (twine_button.click_imgButton()) {twine_button_go();} else
    // SG button click --> story reset (always possible)
    if (sg_button.click_imgButton()) {
      initial_page_setup();
      // hide_all_menus();
      generic_graph_setup();
      // menu_checkbox_setup();
      story_specific_setup();
      modality = "INI";
    }
    break;
  case "NAV":
    // mouse in the NAV/EDT choice area
    if (nav_edt_button.click_rectButton()) {nav_edt_go();} else
    // if mouse in the central editing area
    //if (mouseX < width-right_offset && mouseY > top_offset &&
        //mouseX > left_offset && mouseY < height) {
      // selection of edge for advancing in navigation
      edge_selection_nav();
    //}
    break;
  }
}


public void keyPressed() {  
  key_ok = false;
  switch(modality) {
  case "EDT":
    // =======================================
    // ========= SAVE AND EXPORT =============
    // =======================================
    if (key=='b') { // twine
      // ========= EXPORT TO TWINE HARLOWE =============
      selectOutput("Select a file to write to:", "write_twine_graph");      
      key_ok = true;
    } else
      // ========= SAVE TO STORYGRAPHIA JSON =============
      // ========= SAVE AS ... (NEW FILE) =============
    if (keyCode==SHIFT) { 
      graph_name = set_graph_name(); selectOutput("Select a file to write to:", "write_storygraph");
      headerStoryCountAndPrint();
      key_ok = true;
    } else
      // ========= SAVE (AS ...) =============
    if (key=='w') { 
      if (graph_name.equals("NULL")) {graph_name = set_graph_name(); selectOutput("Select a file to write to:", "write_storygraph");}
      else {write_storygraph(cur_selection); showMessageDialog(null, "Overwritten current file: " + cur_selection, "Info", INFORMATION_MESSAGE);}
      headerStoryCountAndPrint();
      key_ok = true;
    // ========= CANCEL =============
    } else if (key == 'z') {
      if (i_select_agent!=-1 && (select_type.equals("AGENT")||select_type.equals("NODE+AGENT"))) {
        i_select_agent=-1; select_type="NULL"; selection_possible = true;}  // hide_all_menus();
      if (i_select_agent!=-1 && (select_type.equals("STATE")||select_type.equals("NODE+STATE"))) {
        i_select_state=-1; select_type="NULL"; selection_possible = true;}  // hide_all_menus();
      if (i_select_agent!=-1 && (select_type.equals("TENSION")||select_type.equals("NODE+TENSION"))) {
        i_select_tension=-1; select_type="NULL"; selection_possible = true;}  // hide_all_menus();
      if (i_select_agent!=-1 && (select_type.equals("PROPP")||select_type.equals("NODE+PROPP"))) {
        i_select_pf=-1; select_type="NULL"; selection_possible = true;}  // hide_all_menus();
      if (i_select_node!=-1 && (select_type.equals("NODE+TENSION") || select_type.equals("NODE+PROPP") || select_type.equals("NODE+STATE") || select_type.equals("NODE+STATE"))) {
        nodes[i_select_node].select1 = false; i_select_node=-1; select_type="NULL"; selection_possible = true;  // hide_all_menus();
      }
      if (help_b) {help_b = false;} // exit from help
      key_ok = true;
    // ========= CREATE UNIT =============
    } else if (key=='u') { // create a new unit 
      if (i_select_node==-1) {
        nodes[i_cur_node++]=new Unit(0, 0, diameter_size, diameter_size, "N" + str(hour()) + str(minute()) + str(second()) + node_counter++, "NULL", "NULL TAG");                                        
      }
      key_ok = true;
    // =======================================
    // ========= DELETE AND DETACH =============
    // =======================================
    } else if (key=='d') { 
      // ========= DELETE AGENT: delete the selected agent from the whole story
      if (select_type=="AGENT" && i_select_agent!=-1) {
        // hide_all_menus(); agents[i_select_agent].delete();
        i_select_agent=-1; select_type="NULL"; selection_possible = true;
      } 
      // ========= DETACH AGENT: detach the selected agent from the selected unit
      else if (select_type=="NODE+AGENT" && i_select_node!=-1 && i_select_agent!=-1) {
        // hide_all_menus();
        Unit u = (Unit) nodes[i_select_node]; Agent a = agents[i_select_agent];
        u.delete_unit_agent(a.name); 
        nodes[i_select_node].select1 = false; i_select_node=-1; 
        i_select_agent=-1; 
        select_type="NULL"; selection_possible = true; 
      }
      // ========= DELETE TENSION: delete the selected tension from the whole story
      else if (select_type=="TENSION" && i_select_tension!=-1) {
        // hide_all_menus(); 
        tensions[i_select_tension].delete();
        i_select_tension=-1; select_type="NULL"; selection_possible = true;
      } 
      // ========= DETACH TENSION: detach the selected tension from the selected unit
      else if (select_type=="NODE+TENSION" && i_select_node!=-1 && i_select_tension!=-1) {
        // hide_all_menus();
        Unit u = (Unit) nodes[i_select_node]; Tension t = tensions[i_select_tension];
        u.delete_tension_name(); 
        nodes[i_select_node].select1 = false; i_select_node=-1; 
        i_select_tension=-1; select_type="NULL"; selection_possible = true; 
      // ========= DELETE STATE: delete the selected state from the whole story
      } else if (select_type=="STATE" && i_select_state!=-1) {
        // hide_all_menus(); update_states(states[i_select_state].name,"DEL");
        i_select_state=-1; select_type="NULL"; selection_possible = true;
      } 
      // ========= DETACH STATE: detach the selected state from the selected unit
      else if (select_type=="NODE+STATE" && i_select_node!=-1 && i_select_state!=-1) {
        // hide_all_menus();
        Unit u = (Unit) nodes[i_select_node]; State s = states[i_select_state];
        u.delete_unit_precondition(s.name);// u.delete_unit_precondition(s.id); 
        u.delete_unit_effect(s.name); // u.delete_unit_effect(s.id); 
        nodes[i_select_node].select1 = false; i_select_node=-1; i_select_state=-1; 
        select_type="NULL"; selection_possible = true; 
      }
      // ========= DETACH PROPP FUNCTION: detach the selected propp function from the selected unit
      else if (select_type=="NODE+PROPP" && i_select_node!=-1 && i_select_pf!=-1) {
        // hide_all_menus();
        Unit u = (Unit) nodes[i_select_node]; 
        if (u.unit_propp_tag_index == i_select_pf) {
          cur_unit_propp_tag_index = -1; u.modify_propp_tag(); // modify the propp tag
        } else {showMessageDialog(null, "Different Propp tag selected!", "Alert", ERROR_MESSAGE);}
        nodes[i_select_node].select1 = false; i_select_node=-1;  // unselect node
        propp_functions[i_select_pf].selected = false; i_select_pf=-1; // unselect pf
        select_type="NULL"; selection_possible = true; // section possible again
      }
    // } else if (key=='m') { // move a node
      //if (!select_type.equals("AGENT") && i_move!=-1) {// hide_all_menus();} 
      key_ok = true;
    // ======================================
    // ====  PROPP (ONLY IN PROPP MODE)  ====
    // ======================================
    } else if (key=='r' && plot_generation_mode.equals("PROPP")) { 
      // modify through buttons
      if (select_type=="NODE+PROPP" && i_select_node!=-1 && i_select_pf!=-1) {
        Unit u = (Unit) nodes[i_select_node]; Propp_function pf = propp_functions[i_select_pf]; 
        cur_unit_propp_tag_index = i_select_pf;
        u.modify_propp_tag(); // modify the tags through the checkbox
        nodes[i_select_node].select1 = false; i_select_node=-1;  // unselect node
        propp_functions[i_select_pf].selected = false; i_select_pf=-1; // unselect pf
        select_type="NULL"; selection_possible = true; // section possible again
      } else
      // modify through menu
      if (select_type=="NODE" && i_select_node!=-1) {
        Unit u = (Unit) nodes[i_select_node]; u.modify_propp_tag(); // modify the tags through the checkbox
        nodes[i_select_node].select1 = false; i_select_node=-1; select_type="NULL"; selection_possible = true; // unselect
      }
      key_ok = true;
    // =======================================================
    // ====  STATE (ONLY IN PAINTING AND SCULPTING MODE)  ====
    // =======================================================
    } else if (key=='s' && (plot_generation_mode.equals("PAINTING") || plot_generation_mode.equals("SCULPTING"))) { 
    // ========= CREATE STATE =============
      if (select_type=="NULL") {
        String state_name = create_state();
        update_states(state_name, "ADD");
      }
      key_ok = true;
    } else if (key=='p' && (plot_generation_mode.equals("PAINTING") || plot_generation_mode.equals("SCULPTING"))) {
    // ========= ADD PRECONDITION OR MODIFY PRECONDITION LIST OF UNIT =============
      if (select_type=="NODE+STATE" && i_select_node!=-1 && i_select_state!=-1) {
        // hide_all_menus();
        Unit u = (Unit) nodes[i_select_node]; State state = states[i_select_state];
        u.add_unit_precondition(state.name);
        nodes[i_select_node].select1 = false; i_select_node=-1; i_select_state=-1; select_type="NULL"; selection_possible = true; 
      //} else if (select_type=="NODE" && i_select_node!=-1 && i_select_state==-1) {
      //  Unit u = (Unit) nodes[i_select_node]; 
      //  u.modify_preconditions_from_checkbox(); // modify the preconditions through the checkboxes
      //  nodes[i_select_node].select1 = false; i_select_node=-1; select_type="NULL"; selection_possible = true; // unselect
      }
      key_ok = true;
    } else if (key=='f' && (plot_generation_mode.equals("PAINTING") || plot_generation_mode.equals("SCULPTING"))) {  
    // ========= ADD EFFECT OR MODIFY EFFECT LIST OF UNIT =============
      if (select_type=="NODE+STATE" && i_select_node!=-1 && i_select_state!=-1 && 
          (plot_generation_mode.equals("PAINTING") || plot_generation_mode.equals("SCULPTING"))) {
        // hide_all_menus();
        Unit u = (Unit) nodes[i_select_node]; State state = states[i_select_state];
        u.add_unit_effect(state.name); 
        nodes[i_select_node].select1 = false; i_select_node=-1; i_select_state=-1; select_type="NULL"; selection_possible = true; 
      }
      key_ok = true;
    // ==========================================
    // ===== TENSION (ONLY IN TENSION MODE) =====
    // ==========================================
    } else if (key=='y' && (plot_generation_mode.equals("TENSION"))) { 
      // ========= CREATE TENSION =============
      if (select_type=="NULL") {
        String tension_name = create_tension();
        update_tension_lists(tension_name, 50, "ADD");
      } else
      // ========= MODIFY TENSION VALUE =============
      if (select_type=="TENSION" && i_select_tension!=-1) {
        // hide_all_menus();
        Tension t = (Tension) tensions[i_select_tension]; 
        t.modify_tension_value();  // modify the tension value through the input dialog
        tension_layout_update(t.name); // update all the y positions of units
        i_select_tension=-1; select_type="NULL"; selection_possible = true; // unselect
      } else
      // ========= MODIFY UNIT TENSION FROM MENU =============
      if (select_type=="NODE" && i_select_node!=-1) {
        Unit u = (Unit) nodes[i_select_node]; // u.modify_tension_name_from_checkbox(); // modify the tension through the checkbox
        nodes[i_select_node].select1 = false; i_select_node=-1; select_type="NULL"; selection_possible = true; // unselect
      } else 
      // ========= ASSIGN TENSION TO A UNIT =============
      if (select_type=="NODE+TENSION" && i_select_node!=-1 && i_select_tension!=-1) {
        // hide_all_menus();
        Unit u = (Unit) nodes[i_select_node]; 
        Tension t = tensions[i_select_tension];
        u.modify_tension_name(t.name);
        // u.unit_tension_name = t.name;
        // add tension to the unit
        nodes[i_select_node].select1 = false; i_select_node=-1; i_select_tension=-1; 
        select_type="NULL"; selection_possible = true; // unselect
      }
      key_ok = true;
    // ===============================
    // ========= AGENT =============
    // ===============================
    } else if (key=='a') { // STORY SPECIFIC: add a new agent in a unit 
      // ========= CREATE AGENT AND ADD TO UNIT =============
      if (select_type=="NODE" && i_select_node!=-1) {
        // hide_all_menus();
        Unit u = (Unit) nodes[i_select_node];
        u.add_unit_agent("NULL"); 
        nodes[i_select_node].select1 = false; node_deselection(); // i_select_node=-1; select_type="NULL"; selection_possible = true; 
      } 
      // ========= ADD AGENT TO UNIT =============
      else if (select_type=="NODE+AGENT" && i_select_node!=-1 && i_select_agent!=-1) {
        // hide_all_menus();
        Unit u = (Unit) nodes[i_select_node]; Agent a = agents[i_select_agent];
        u.add_unit_agent(a.name); 
        nodes[i_select_node].select1 = false; i_select_node=-1; 
        i_select_agent=-1; 
        select_type="NULL"; selection_possible = true; 
      }
      key_ok = true;
    // ========= MODIFY TEXT =============
    } else if (key=='t' && !select_type.equals("NULL")) { // modify the text of the selected agent
      if (select_type=="AGENT" && i_select_agent!=-1) {
        // hide_all_menus();
        agents[i_select_agent].modify_name(); // modify the text
        i_select_agent=-1; select_type="NULL"; selection_possible = true; // unselect
      } else
      if (select_type=="STATE" && i_select_state!=-1) {
        // hide_all_menus();
        states[i_select_state].modify_name(); // modify the text
        i_select_state=-1; select_type="NULL"; selection_possible = true; // unselect
      } else
      if (select_type=="TENSION" && i_select_tension!=-1) {
        // hide_all_menus();
        tensions[i_select_tension].modify_name(); // modify the text
        i_select_tension=-1; select_type="NULL"; selection_possible = true; // unselect
      }
      key_ok = true;
    } // else {  
    // }      
    break;
  }
  // println("GENERIC KEYPRESS");
  generic_graph_keyPressed();
  if (!key_ok) {showMessageDialog(null, "No action! Press 'h' for help!", "Alert", ERROR_MESSAGE);}
}

// *** STORY SPECIFIC SETUP

public void storygraphia_license_setup() { 
  // flex_write_lines_in_box(String text, font_type, float font_aspect_ratio, String x_align, String y_align, float x_center, float y_center, float x_width, float y_height)
  imageMode(CENTER); image(sg_logo, width/2-xo, 3*y_credits-yo, sg_logo.width*2*y_credits/sg_logo.height, 2*y_credits);
  flex_write_lines_in_box("STORYGRAPHIA 0.9.6", default_font_name, default_font_aspect_ratio, "CENTER", "CENTER", width/2-xo, y_credits-yo, width-y_credits*2, y_credits);
  flex_write_lines_in_box(storygraphia_license, default_font_name, default_font_aspect_ratio, "CENTER", "CENTER", width/2-xo, height-bottom_offset-yo, width-left_offset*2, y_credits);
} 

public void story_specific_setup() {
  tags_setup();
  agents_setup(); 
  propp_setup();
  states_setup();
  // tension_bg_setup();
  tensions_setup();
}

public void story_initialization_go() {
  // println("story_initialization_go");
  if (scratch_button.click_rectButton()) {
    modality="PRP"; plot_generation_mode = "MANUAL"; white_page=true;
  } else if (file_button.click_rectButton()) {
    selectInput("Select a file to process:", "load_storytext"); 
    modality="PRP"; plot_generation_mode = "MANUAL";
  //} else if (load_button.click_rectButton()) {
  //  selectInput("Select a file to process:", "load_storygraph"); 
  //  modality="PRP"; plot_generation_mode = "MANUAL";
  } else if (manual_button.click_rectButton()) {
    selectInput("Select a file to process:", "load_storygraph"); 
    modality="PRP"; plot_generation_mode = "MANUAL";
  } else if (propp_button.click_rectButton()) {
    selectInput("Select a file to process:", "load_storygraph"); 
    modality="PRP"; plot_generation_mode = "PROPP";
  //} else if (constraints_sculpting_button.click_rectButton()) {
  //  selectInput("Select a file to process:", "load_storygraph"); 
  //  modality="PRP"; plot_generation_mode = "SCULPTING";
  } else if (constraints_painting_button.click_rectButton()) {
    selectInput("Select a file to process:", "load_storygraph"); 
    modality="PRP"; plot_generation_mode = "PAINTING";
  } else if (arc_button.click_rectButton()) {
    selectInput("Select a file to process:", "load_storygraph"); 
    modality="PRP"; plot_generation_mode = "TENSION";
  }
}

public void nav_edt_go() {
  // hide_all_menus();
  if (modality.equals("EDT") && nav_edt_button.click_rectButton()) {
    nav_edt_button.text = "NAV";
    select_start_node_in_nav();
    modality="NAV"; 
  } else if (modality.equals("NAV") && nav_edt_button.click_rectButton()) {
    nav_edt_button.text = "EDT";
    modality="EDT"; cur_nav_node_index=-1;
  } 
}

public void man_prp_ptg_tns_go() {
  // hide_all_menus();
  if (modality.equals("EDT") && man_prp_ptg_tns_switch_button.click_rectButton()) {
    if (plot_generation_mode.equals("MANUAL")) {plot_generation_mode = "PROPP";} else
    if (plot_generation_mode.equals("PROPP")) {plot_generation_mode = "PAINTING";} else
    if (plot_generation_mode.equals("PAINTING")) {plot_generation_mode = "TENSION";} else
    if (plot_generation_mode.equals("TENSION")) {plot_generation_mode = "MANUAL";} 
    modality = "PRP";
  } 
}

public void twine_button_go() {
  // hide_all_menus();
  if (twine_button.click_imgButton()) {
    selectOutput("Select a file to write to:", "write_twine_graph");
    modality="EDT"; cur_nav_node_index=-1;
  } 
}
public void ollama_button_go() {
  // hide_all_menus();
  if (ollama_button.click_imgButton()) {
  //  selectOutput("E' il momento di Olllama", "Ora apriamo Ollama");
    modality="EDT"; cur_nav_node_index=-1;
    // Crea una nuova finestra Swing solo se non esiste già
   if (ollamaWindow == null) {
    if (frame == null) {
        frame = new JFrame("Ollama Window");
        frame.setSize(1000, 600);
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        ollamaWindow = new OllamaWindow(); // Crea l'oggetto OllamaWindow
        frame.add(ollamaWindow); // Aggiungi il pannello alla finestra Swing

        frame.setLocationRelativeTo(null); // Centra la finestra sullo schermo
        frame.setVisible(true);

        // Assicura che la finestra venga chiusa correttamente
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent e) {
                frame = null; // Resetta il riferimento alla finestra
                ollamaWindow = null; // Resetta il riferimento a OllamaWindow
            }
        });
    }

    }
    }

  } 


public void select_start_node_in_nav() {
  if (i_select_node!=-1) {cur_nav_node_index = i_select_node; nodes[i_select_node].select1=false; node_deselection(); } // i_select_node=-1; selection_possible=true; } 
  else {
    boolean cur_nav_node_index_found = false;
    while (!cur_nav_node_index_found) {
      int cur_nav_node_index_proposal = PApplet.parseInt(random(i_cur_node));
      if (!nodes[cur_nav_node_index_proposal].deleted) {
        cur_nav_node_index=cur_nav_node_index_proposal;
        cur_nav_node_index_found=true;
      }
    }
  }
  nodes[cur_nav_node_index].x_nav=0; nodes[cur_nav_node_index].y_nav=0;
  nodes[cur_nav_node_index].w_nav=actual_height/3; nodes[cur_nav_node_index].h_nav=actual_height/3;
  nodes[cur_nav_node_index].compute_pred_subs();
  float offset = actual_height/i_cur_predecessor;
  for (int i=0; i<i_cur_predecessor; i++) {
    int node_index = searchNodeIdIndex(predecessor_node_ids[i]);
    nodes[node_index].y_nav = (top_offset + i * offset + offset/2)/zoom-yo;
    nodes[node_index].x_nav = (left_offset+actual_width/6)/zoom-xo;
    nodes[node_index].w_nav=diameter_size;
    nodes[node_index].h_nav=diameter_size;
  }
  offset = actual_height/i_cur_subsequent;
  for (int i=0; i<i_cur_subsequent; i++) {
    int node_index = searchNodeIdIndex(subsequent_node_ids[i]);
    nodes[node_index].y_nav = (top_offset + i * offset + offset/2)/zoom-yo;
    nodes[node_index].x_nav = (left_offset+5*actual_width/6)/zoom-xo;
    nodes[node_index].w_nav=diameter_size;
    nodes[node_index].h_nav=diameter_size;
  }
}

public void next_node_in_nav() {
  for (int i=0; i<i_cur_node; i++) {
    nodes[i].x_nav=-1; nodes[i].y_nav=-1;
    nodes[i].w_nav=0; nodes[i].h_nav=0;
  }
  for (int i=0; i<i_cur_edge; i++) {
    edges[i].label_x_nav=-1; edges[i].label_y_nav=-1;
  }
  nodes[cur_nav_node_index].x_nav=0; nodes[cur_nav_node_index].y_nav=0;
  nodes[cur_nav_node_index].w_nav=actual_height/3; nodes[cur_nav_node_index].h_nav=actual_height/3;
  nodes[cur_nav_node_index].compute_pred_subs();
  float offset = actual_height/i_cur_predecessor;
  for (int i=0; i<i_cur_predecessor; i++) {
    int node_index = searchNodeIdIndex(predecessor_node_ids[i]);
    nodes[node_index].y_nav = (top_offset + i * offset + offset/2)/zoom-yo;
    nodes[node_index].x_nav = (left_offset+actual_width/6)/zoom-xo;
    nodes[node_index].w_nav=diameter_size;
    nodes[node_index].h_nav=diameter_size;
  }
  offset = actual_height/i_cur_subsequent;
  for (int i=0; i<i_cur_subsequent; i++) {
    int node_index = searchNodeIdIndex(subsequent_node_ids[i]);
    nodes[node_index].y_nav = (top_offset + i * offset + offset/2)/zoom-yo;
    nodes[node_index].x_nav = (left_offset+5*actual_width/6)/zoom-xo;
    nodes[node_index].w_nav=diameter_size;
    nodes[node_index].h_nav=diameter_size;
  }
}

public void story_show_menus() {
  if (i_select_node!=-1) {
    Unit u;
    switch(plot_generation_mode) {
      case "MANUAL": 
        // nodes[i_select_node].show_tags();
        // nodes[i_select_node].show_tag();
        u = (Unit) nodes[i_select_node];
        u.show_agents_and_tag();
        break;
      case "PAINTING": 
        u = (Unit) nodes[i_select_node];
        // u.show_states();
        u.show_preconditions_and_effects();
        break;
      case "SCULPTING": 
        u = (Unit) nodes[i_select_node];
        // u.show_states();
        u.show_preconditions_and_effects();
        break;
      case "TENSION": 
        u = (Unit) nodes[i_select_node];
        // u.show_tags();
        u.show_tension();
        break;
      case "PROPP": 
        u = (Unit) nodes[i_select_node];
        // u.show_tags();
        u.show_propp_tag();
        break;
    }
  }
}
// LIBRARY FOR AGENTS

Agent[] agents;
String[] agent_ids; int agent_id_suffix = 0; // Agent id's are printed in the Agent box
int total_agents;
int i_cur_agent;
int i_select_agent;

public void agents_settings() {
  total_agents = 1000; 
}

public void agents_setup() {
  i_cur_agent = 0;
  i_select_agent = -1;
  agents = new Agent[total_agents]; 
  agent_ids = new String[total_agents];
}

public void agents_color_setup() {
  colorMode(HSB, 360, 100, 100);
  if (i_cur_agent>0) {
    float color_interval = 360 / i_cur_agent; float start = random(360);
    for (int i=0; i < i_cur_agent; i++) {
      agents[i].agent_color = color((start+color_interval*i)%360,100,100);
    }
  }
}

public void agents_position_setup() {
  if (i_cur_agent>0) {
    float agent_height = actual_height / i_cur_agent;
    if (agent_height >= diameter_size) {agent_height=diameter_size;} 
    for (int i=0; i < i_cur_agent; i++) {
      agents[i].h = agent_height; agents[i].w = left_offset; // square
      agents[i].x = (agents[i].w/2)/zoom-xo; 
      agents[i].y = (2 * top_offset + (agent_height + margin)*(i + 0.5f))/zoom-yo;
      agents[i].tooltip.x = agents[i].x; agents[i].tooltip.y = agents[i].y;
    }
  }
}

public void update_agents(String agt_name, String mode) {
  switch (mode) {
    case("ADD"):
      if (searchAgent(agt_name)==null) {
        agents[i_cur_agent]=new Agent(agt_name);
        i_cur_agent++;
      }
      break;
    case("DEL"):
      Agent[] agents_aux = new Agent[i_cur_agent-1]; String[] agent_ids_aux = new String[i_cur_agent-1];
      int index = searchAgentIndex(agt_name);
      if (index!=-1) {
        for (int i=0; i<index; i++) {agents_aux[i]=agents[i]; agent_ids_aux[i]=agent_ids[i];}
        for (int i=index; i<i_cur_agent-1; i++) {agents_aux[i]=agents[i+1]; agent_ids_aux[i]=agent_ids[i+1];}
        for (int i=0; i<agents_aux.length; i++) {agents[i]=agents_aux[i]; agent_ids[i]=agent_ids_aux[i];}
        i_cur_agent--;
      }
      break;
  } // END SWITCH
  agents_color_setup();
  agents_position_setup();
  // println("update_agents: " + i_cur_agent + " agents");
}

public int agent_click() {
  int i_select_aux=-1;
  float x = mouseX; float y = mouseY; // capture mouse position
  for (int i=0; i<i_cur_agent; i++) { // for each agent 
    if (x < (agents[i].x+agents[i].w/2)*zoom+xo && x > (agents[i].x-agents[i].w/2)*zoom+xo && // if the mouse is over the agent box
        y < (agents[i].y+agents[i].h/2)*zoom+yo && y > (agents[i].y-agents[i].h/2)*zoom+yo) {
        i_select_aux=i; 
    }
  } // END FOR
  return i_select_aux;
}

public void agent_selection() {
  int i_select_aux = agent_click(); // choose an agent
  if (i_select_aux!=-1) { // if successful
    if (selection_possible) { // if nothing was selected before
      i_select_agent = i_select_aux; select_type = "AGENT";  selection_possible=false;
    } else 
    if (select_type.equals("AGENT")) { // if previous selection is an agent
      if (i_select_agent==i_select_aux) { // if same agent, deselect
        i_select_agent = -1; select_type = "NULL";  selection_possible=true;
      }
    } else
    if (select_type.equals("NODE")) { // if previous selection is a node, allow agent selection
      i_select_agent = i_select_aux; select_type = "NODE+AGENT";  selection_possible=false;
    }
  } // END AGENT WAS SELECTED
}

public void draw_agents() {
  // Agents header
  if (!white_page) {
    fill(text_color);
    flex_write_lines_in_box("AGTs", default_font_name, default_font_aspect_ratio, 
                          "CENTER", "CENTER", 
                          (left_offset/2)/zoom-xo, (1.5f*top_offset)/zoom-yo, left_offset, top_offset); 
  }
  for (int i=0; i < i_cur_agent; i++) {
    // println("color of agent " + i);
    if ((select_type=="AGENT"||select_type=="NODE+AGENT") && i==i_select_agent) {fill(select_color);}
    else {fill(agents[i].agent_color);} 
    if (!agents[i].deleted) {
      rectMode(CENTER);
      rect(agents[i].x,agents[i].y,agents[i].w,agents[i].h);
      if ((select_type=="AGENT"||select_type=="NODE+AGENT") && i==i_select_agent) {fill(select_text_color);} 
      else {fill(text_color);}
      flex_write_lines_in_box(agents[i].id, default_font_name, default_font_aspect_ratio, 
                              "CENTER", "CENTER", 
                              agents[i].x, agents[i].y, agents[i].w, agents[i].h);
    }
  }
}

public String create_agent_id(String new_name) { // creates id's (3 letters) for agents
  boolean id_ok = false; String id_aux = "NULL"; 
  String suffix = str(agent_id_suffix); if (suffix.length()==1) {suffix = "0"+suffix;}
  int index1=0, index2=1, index3=2;
  while (!id_ok) {
    // proposal
    if (new_name.length()>=3) {id_aux = str(new_name.charAt(index1)) + str(new_name.charAt(index2)) + str(new_name.charAt(index3++));}
    else if (new_name.length()>=2) {id_aux = str(new_name.charAt(index1)) + str(new_name.charAt(index2++)) + str(0);}
    else if (new_name.length()>=1) {id_aux = str(new_name.charAt(index1)) + str(0) + str(0);}
    // disposal
    if (searchStringIndex(id_aux, agent_ids, 0, i_cur_agent)==-1) {
      id_ok=true;
    }
  }
  println("NEW AGENT ID = " + id_aux);
  return id_aux;
}  


class Agent {
  String id;
  String name;
  float x,y;
  float w,h;
  int agent_color;
  boolean deleted;
  ToolTip tooltip;
  
  Agent (String _name) {
    name = _name; x=-1; y=-1; w=diameter_size; h=diameter_size; deleted = false;
    tooltip = new ToolTip(name, x, y-w, size_x/2, size_y/2, default_font_name, default_font_size, default_font_aspect_ratio);
    id = create_agent_id(name); agent_ids[i_cur_agent]=id;
  }

  public void delete() {
    // println("deleting agent " + name); //<>//<>//<>//<>//
    deleted = true; 
    // deleted_nodes[num_deleted++]=i;
    for (int j=0; j<i_cur_node; j++) {
      Unit u = (Unit) nodes[j];
      // print4check("Before: Unit " + u.id + "(" + u.unit_agents_counter + " agents)", 0, u.unit_agents_counter, u.unit_agents);
      int k=0; boolean found = false;
      while (k<u.unit_agents_counter && !found) {
        if (u.unit_agents[k].equals(name)) {found = true;} else {k++;}
      } // END FOR EACH UNIT AGENT
      if (found) {println("DELETE"); u.unit_agents = deleteStringByIndex(k, u.unit_agents); u.unit_agents_counter--;}
      // print4check("After: Unit " + u.id + "(" + u.unit_agents_counter + " agents)", 0, u.unit_agents_counter, u.unit_agents);
    } // END FOR EACH UNIT
    update_agents(name,"DEL");
  }

  public void modify_name() {
    Agent aux_a;
    String name_aux = showInputDialog("Please enter new agent name", name);
    if (name_aux == null || "".equals(name_aux))
      showMessageDialog(null, "Empty input!", "Alert", ERROR_MESSAGE);
    else {
      aux_a = searchAgent(name_aux);
      if (aux_a!=null)
        {showMessageDialog(null, "AGENT \"" + name_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);}
      else {
      showMessageDialog(null, "AGENT \"" + name + "\" changed name into " + name_aux, "Info", INFORMATION_MESSAGE);
      for (int i=0; i<i_cur_node; i++) { // update agent name in all units containing it
        Unit u = (Unit) nodes[i];
        u.modify_agent_name(name, name_aux);
      }
      name=name_aux; tooltip.text=name;
      // String old_id = id;
      int i = searchStringIndex(id, agent_ids, 0, i_cur_agent);
      agent_ids = deleteStringByIndex(i, agent_ids); i_cur_agent--; // temporarily, agents are decreased
      id = create_agent_id(name); 
      agent_ids = insertStringAtIndex(id, i, agent_ids); i_cur_agent++;
      // replaceString(old_id, id, agent_ids, 0, i_cur_agent);
      }
    }
  }
  
} // END CLASS AGENT




public Agent searchAgent(String agent_name) {
  for (int i=0; i<i_cur_agent; i++) {
    if (agents[i].name.equals(agent_name)) {return agents[i];} 
  }
  return null;
}

public int searchAgentIndex(String agent_name) {
  for (int i=0; i<i_cur_agent; i++) {
    if (agents[i].name.equals(agent_name)) {return i;} 
  }
  return -1;
}

// agent name layover through tooltip
public void agent_layover() {
  // search for the tooltip to display
  float x = mouseX; float y = mouseY; // capture mouse position
  for (int i=0; i<i_cur_agent; i++) { // for each agent 
    ToolTip tt = agents[i].tooltip; 
    if (x < (agents[i].x+agents[i].w/2)*zoom+xo && x > (agents[i].x-agents[i].w/2)*zoom+xo) { // if the mouse is over such box
      if (y < (agents[i].y+agents[i].h/2)*zoom+yo && y > (agents[i].y-agents[i].h/2)*zoom+yo) {
        tt.x= x-xo; tt.y= y-yo; 
        int c = color(0, 0, 80, 10); // color(0, 80, 255, 30);
        tt.setBackground(c); // color(0,80,255,30));
        tt.display();
      }
    }
  } // END FOR
}  
PrintWriter storyprint; // file that contains the story print

public void headerStoryCountAndPrint() {
  storyprint = createWriter("data/storyprints/"+graph_name+"_storyprint.txt");
  storyprint.println("STORYGRAPHIA STORY PRINT"); // header 
  storyprint.println("===================================================== \n"); 
  String[] unit_id_list = new String[totalNum]; for (int i=0; i<unit_id_list.length; i++) {unit_id_list[i]="NULL";}
  int unit_id_list_counter = 0;
  int num_stories = storyCountAndPrint("", unit_id_list, unit_id_list_counter, "", -1, 0); // empty story, empty unit id concatenation, no last unit, 0 stories
  storyprint.println("===================================================== \n"); 
  String propp_used="NO Propp functions"; 
  String precond_eff_used="NO logic constraints"; 
  String arc_used="NO tension arc";
  float ratio = (float) num_stories / i_cur_node; // computing ratio
  for (int i=0; i<i_cur_node; i++) { // checking constraints used
    Unit u = (Unit) nodes[i];
    if (u.unit_propp_tag_index!=-1) {propp_used="Propp functions";}
    if (u.unit_effects_counter!=0) {precond_eff_used="Logic constraints";}
    if (!u.unit_tension_name.equals("NULL")) {arc_used="Tension arc";}
  }
  storyprint.println(" STORYGRAPHIA STATISTICS, " + graph_name); 
  storyprint.println(i_cur_node + " units, " + i_cur_tag + " tags " + i_cur_agent + " agents "); 
  storyprint.println(propp_used + ", " + precond_eff_used + ", " + arc_used); 
  storyprint.println(num_stories + " potential linear stories, ratio " + ratio); 
  storyprint.println(" in plot generation mode: " + plot_generation_mode); 
  storyprint.flush();
}

public String unitType(Unit u) { // returns one of {"START", "MIDDLE", "END", "NULL"}
  String unit_type = "NULL"; 
  boolean head_b = false; boolean tail_b = false; // default: isolated "NULL" unit 
  for (int i=0; i<i_cur_edge;i++) {if (edges[i].head_id==u.id) {head_b = true;}} // is unit head of at least one edge?
  for (int i=0; i<i_cur_edge;i++) {if (edges[i].tail_id==u.id) {tail_b = true;}} // is unit tail of at least one edge?
  if (head_b && tail_b) {unit_type = "MIDDLE";} else 
  if (head_b) {unit_type = "END";} else
  if (tail_b) {unit_type = "START";}
  return unit_type;
}

public int storyCountAndPrint(String preStory, String[] _unit_id_list, int _unit_id_list_counter, String unit_id_concatenation, int lastUnitIndex, int preCount) { 
  String story = preStory; int count = preCount; boolean loop = false;
  String[] uil = _unit_id_list; int uilc = _unit_id_list_counter; String cur_unit_id_concatenation = unit_id_concatenation;
  // for each node
  for (int i=0; i<i_cur_node; i++) {
    Unit u = (Unit) nodes[i];
    if (story.equals("")) {// if story is empty string 
      if (unitType(u).equals("START") && lastUnitIndex==-1) { // if unit type == START and no previous unit
        String new_story = story + "\n" + u.text; // set story to unit text and call this function recursively
        // int ret = storyCountAndPrint(new_story, list+str(i), i, count);
        uil[uilc] = u.id; uilc++;
        int ret = storyCountAndPrint(new_story, uil, uilc, cur_unit_id_concatenation+u.id, i, count);
        if (ret==-1) {println("ERROR IN START STORY UNIT CHAINING!"); return -1;} else {count = ret;}
      } // END if correct START
    } else { // else (story is not empty)
      int edge_index = search_edge_head_tail_index(i,lastUnitIndex, plot_generation_mode);
      if (edge_index!=-1) {// if lastUnit is a previous unit of the current one  
        String new_story = story + "\n-\n--> " + edges[edge_index].label + "\n-\n" + u.text; // add unit text to story 
        if (searchStringIndex(u.id, uil, 0, uilc-1)!=-1) {loop = true;}
        if (unitType(u).equals("END") || loop) { // if unit type = END 
          // increment count and print story in the output file; then exit
          count++;
          // storyprint.write("\n" + count + ": " + list+"-"+str(i) + "\n" + new_story + "\n+++++++++++++++++");
          if (loop) {
            storyprint.write("\n" + count + ": " + cur_unit_id_concatenation+"-"+u.id + "(LOOP) \n" + new_story + "\n\n+++++++++++++++++++++++++++++++++");
          } else {
            storyprint.write("\n" + count + ": " + cur_unit_id_concatenation+"-"+u.id + "\n" + new_story + "\n\n+++++++++++++++++++++++++++++++++");
          }
          storyprint.write("\n+++++++++++++++++++++++++++++++++\n+++++++++++++++++++++++++++++++++\n");
          // println(count + " " + new_story);
          //return count;
        } else {// else 
          if (unitType(u).equals("MIDDLE") && !loop) { // if unit type = MIDDLE
            // int ret = storyCountAndPrint(new_story, list+str(i), i, count); // call this function recursively
            uil[uilc] = u.id; uilc++;
            int ret = storyCountAndPrint(new_story, uil, uilc, cur_unit_id_concatenation+"-"+u.id, i, count); // call this function recursively
            if (ret==-1) {println("ERROR IN CONTINUING STORY UNIT CHAINING!"); return -1;} // if error, return -1
            else {count = ret;}
          }
        }
      }
    }
  }
  storyprint.flush();
  return count;
}
// AUX FUNCTIONS

// STRING FUNCTIONS
public int searchStringIndex(String id, String[]list, int left, int right) {
  // println(id);
  for (int i=left; i<right; i++) {
    if (list[i].equals(id)) {return i;}
  }
  return -1;
}

public String[] deleteStringByIndex(int index, String[]list) {
  int i = 0; String[] aux_s = new String[list.length];
  while (i<index) {aux_s[i]=list[i]; i++;}
  aux_s[list.length-1] = null;
  for (i=index; i<list.length-1;i++) {aux_s[i] = list[i+1];}
  return aux_s;
}

public String[] insertStringAtIndex(String str, int index, String[]list) {
  int i = 0; String[] aux_s = new String[list.length];
  while (i<index) {aux_s[i]=list[i]; i++;}
  aux_s[index] = str;
  for (i=index+1; i<list.length-1;i++) {aux_s[i] = list[i-1];}
  return aux_s;
}

public void replaceString(String old_name, String new_name, String[]list, int left, int right) {
  for (int i=left; i<right; i++) {
    if (list[i].equals(old_name)) {list[i]=new_name;}
  }
}

public boolean allNullStrings(String[] list) {
  for (int i=0; i<list.length; i++) {
    if (!list[i].equals("NULL")) return false;
  }
  return true;
}

// PRINTING
public void print4check(String header, int left_end, int right_end, String[] string_array) {
  print(header); 
  for (int j=left_end; j<right_end; j++) {print(" " + string_array[j]);} 
  print("\n");
}

// IMAGING
public float[] img_fitting_surface (PImage img, float w, float h) {
  float img_aspect_ratio = img.width / img.height;  float surface_aspect_ratio = w/h;
  float display_w = img.width; float display_h = img.height;
  // If your rectangle's aspect ratio is greater than that of your image, then scale the image uniformly based on the heights (rectangle height / image height).
  // If your rectangle's aspect ratio is less than that of your image, then scale the image uniformly based on the widths (rectangle width / image width).
  float w_ratio = w/img.width; float h_ratio = h/img.height;
  if (surface_aspect_ratio >= img_aspect_ratio) {display_h = h; display_w = img.width*h_ratio;}
  else {display_w = w; display_h = img.height*w_ratio;}
  float[] dw_dh = {display_w, display_h};  
  return dw_dh;
}
// INTERACTIVE BUTTONS LIBRARY
int rect_button_color;

class rectButton {
  String id; // button identifier
  String text; // button text to print
  float x_coord, y_coord; // coordinates of the button center
  float x_width, y_height; // width and height of the button
  int rbc; // rect button color (fill)
  int rbtc; // rect button text color
  float font_size; // size of text
  
  rectButton(String i, String t, float xc, float yc, float xw, float yh, int c, int tc, float fs) { 
    id = i; text = t; x_coord = xc; y_coord = yc; x_width = xw; y_height = yh; rbc=c; rbtc=tc; font_size=fs;
  } 
  
  public void draw_rectButtonCenter() {
    rectMode(CENTER); fill(rbc); strokeWeight(1);
    rect(x_coord, y_coord, x_width, y_height, x_width/10);
    textAlign(CENTER, CENTER); fill(rbtc); textSize(font_size); text(text, x_coord, y_coord);
  }

  public void draw_rectButtonRight() {
    rectMode(CENTER); fill(rbc); strokeWeight(1);
    rect(x_coord-x_width/2, y_coord, x_width, y_height, x_width/10);
    textAlign(CENTER, CENTER); fill(rbtc); textSize(font_size); text(text, x_coord-x_width/2, y_coord);
  }

  public void draw_rectButtonLeft() {
    rectMode(CENTER); fill(rbc); strokeWeight(1);
    rect(x_coord+x_width/2, y_coord, x_width, y_height, x_width/10);
    textAlign(CENTER, CENTER); fill(rbtc); textSize(font_size); text(text, x_coord+x_width/2, y_coord);
  }

  public boolean click_rectButton() {
    if (mouseX > (x_coord-x_width/2)*zoom+xo && mouseX < (x_coord+x_width/2)*zoom+xo && 
        mouseY > (y_coord-y_height/2)*zoom+yo && mouseY < (y_coord+y_height/2)*zoom+yo) {return true;}
    return false;
  }
}

class imgButton {
  PImage img;
  String txt;
  float surface_width, surface_height;
  float display_width, display_height;
  float x_coord, y_coord;
  ToolTip tooltip;
  
  imgButton(PImage i, String t, float x, float y, float s_w, float s_h) { 
    img = i; txt = t; x_coord = x; y_coord = y; surface_width = s_w; surface_height = s_h;
    float[] display_sizes = img_fitting_surface(img, surface_width, surface_height);
    display_width = display_sizes[0]; display_height = display_sizes[1];
    tooltip = new ToolTip(txt, x_coord, y_coord, size_x/2, size_y/2, default_font_name, default_font_size, default_font_aspect_ratio);
  } 

  public void draw_imgButtonCenter() {
    imageMode(CENTER); 
    image(img, x_coord, y_coord, display_width, display_height);
  }

  public boolean click_imgButton() {
    if (mouseX > (x_coord-display_width/2)*zoom+xo && mouseX < (x_coord+display_width/2)*zoom+xo && 
        mouseY > (y_coord-display_height/2)*zoom+yo && mouseY < (y_coord+display_height/2)*zoom+yo) {return true;}
    return false;
  }
  
}

// button text layover through tooltip
public void button_layover() {
  // search for the tooltip to display
  float x = mouseX; float y = mouseY; // capture mouse position
   if (x < (ollama_button.x_coord+ollama_button.display_width/2)*zoom+xo && x > (ollama_button.x_coord-ollama_button.display_width/2)*zoom+xo && // if the mouse is over the ollama button
     (y < (ollama_button.y_coord+ollama_button.display_height/2)*zoom+yo && y > (ollama_button.y_coord-ollama_button.display_height/2)*zoom+yo)) {
      // ToolTip(String _text, float _x, float _y, float _max_w, float _max_h, String _font_name, float _font_size, float _font_aspect_ratio)
      ToolTip tt = new ToolTip(ollama_button.txt,
                               ollama_button.x_coord*zoom+xo, (ollama_button.y_coord-ollama_button.display_height)*zoom+yo, 
                               size_x/2, size_y/2, 
                               default_font_name, default_font_size, default_font_aspect_ratio);
      tt.x= x/zoom-xo; tt.y= y/zoom-yo; 
      int c = color(0, 0, 80, 10); // color(0, 80, 255, 30);
      tt.setBackground(c); // color(0,80,255,30));
      tt.display();
  } else 
  if (x < (twine_button.x_coord+twine_button.display_width/2)*zoom+xo && x > (twine_button.x_coord-twine_button.display_width/2)*zoom+xo && // if the mouse is over the twine button
     (y < (twine_button.y_coord+twine_button.display_height/2)*zoom+yo && y > (twine_button.y_coord-twine_button.display_height/2)*zoom+yo)) {
      // ToolTip(String _text, float _x, float _y, float _max_w, float _max_h, String _font_name, float _font_size, float _font_aspect_ratio)
      ToolTip tt = new ToolTip(twine_button.txt,
                               twine_button.x_coord*zoom+xo, (twine_button.y_coord-twine_button.display_height)*zoom+yo, 
                               size_x/2, size_y/2, 
                               default_font_name, default_font_size, default_font_aspect_ratio);
      tt.x= x/zoom-xo; tt.y= y/zoom-yo; 
      int c = color(0, 0, 80, 10); // color(0, 80, 255, 30);
      tt.setBackground(c); // color(0,80,255,30));
      tt.display();
  } else 
  if (x < (sg_button.x_coord+sg_button.display_width/2)*zoom+xo && x > (sg_button.x_coord-sg_button.display_width/2)*zoom+xo && // if the mouse is over the sg button
      y < (sg_button.y_coord+sg_button.display_height/2)*zoom+yo && y > (sg_button.y_coord-sg_button.display_height/2)*zoom+yo) {
      // ToolTip(String _text, float _x, float _y, float _max_w, float _max_h, String _font_name, float _font_size, float _font_aspect_ratio)
      ToolTip tt = new ToolTip(sg_button.txt,
                               sg_button.x_coord*zoom+xo, (sg_button.y_coord-sg_button.display_height)*zoom+yo, 
                               size_x/2, size_y/2, 
                               default_font_name, default_font_size, default_font_aspect_ratio);
      tt.x= x/zoom-xo; tt.y= y/zoom-yo; 
      int c = color(0, 0, 80, 10); // color(0, 80, 255, 30);
      tt.setBackground(c); // color(0,80,255,30));
      tt.display();
  }
} 
// GRAPH EDGES
Edge[] edges; // edges in manual, arc, and Propp modes 
String[] edge_creation_modes = {"CONDITIONAL","NON_CONDITIONAL"}; // CURRENTLY NOT USED 
int total_num_edges; 
int i_cur_edge=0; 
int i_cur_painting_edge=0; int i_cur_sculpting_edge=0;
int edge_counter = 0; // = num*2; // numero di archi
int edge_color;

class Edge {
  String head_id, tail_id; 
  String id; // edge identifier
  String label;
  float label_x, label_y;
  float label_x_nav, label_y_nav;
  boolean select, deleted;
  String[] pg_modes; // creation mode: MANUAL, PAINTING, SCULPTING, TENSION, PROPP
  int pg_mode_counter;
  ToolTip tooltip;

  Edge(String head_id_aux, String tail_id_aux, String id_aux, String label_aux, String _pg_mode) {
    head_id = head_id_aux; tail_id = tail_id_aux; id = id_aux; label = label_aux; select=false; deleted=false; 
    pg_modes = new String[5]; for (int i=0; i<pg_modes.length; i++) {pg_modes[i]="NULL";} pg_mode_counter=0;
    if (!_pg_mode.equals("NULL")) {pg_modes[0] = _pg_mode; pg_mode_counter=1; // it is NULL when reading from file
      if (pg_modes[0].equals("MANUAL") || pg_modes[0].equals("PROPP") || pg_modes[0].equals("TENSION")) { // cannot be NULL can occur when loading story file
        pg_modes[0] = "MANUAL"; pg_modes[1] = "TENSION"; pg_modes[2] = "PROPP"; pg_mode_counter=3;
      }
    }
    label_coordinates(); 
    tooltip = new ToolTip(label, label_x, label_y-diameter_size, actual_width/2, actual_height/2, default_font_name, default_font_size, default_font_aspect_ratio);  
    // tooltip = new ToolTip(label, size_x/2, size_y/2, size_x/2, size_y/2, default_font_name, default_font_size, default_font_aspect_ratio);  
  }
  
  public void delete() {
    // println("deleting edge " + id);
    deleted=true;
  }

  public boolean is_pg_mode_edge(String pg_mode) {
    if (searchStringIndex(pg_mode, pg_modes, 0, pg_modes.length)==-1) return false;
    else return true;
  }

  public void add_mode(String pg_mode) {
    if (!is_pg_mode_edge(pg_mode)) {
      pg_modes[pg_mode_counter] = pg_mode; pg_mode_counter++;
    }
  }

  public void modify_label() {
    // public static String showInputDialog(Object message)
    // public static String showInputDialog(Object message, Object initialSelectionValue)
    // public static String showInputDialog(Component parentComponent, Object message)
    // public static String showInputDialog(Component parentComponent, Object message, Object initialSelectionValue)
    // public static String showInputDialog(Component parentComponent, Object message, String title,int messageType) 
    // public static Object showInputDialog(...) // throws HeadlessException
                     // Component parentComponent, --- - the parent Component for the dialog
                     // Object message, --- the Object to display
                     // String title, --- the String to display in the dialog title bar
                     // int messageType, --- the type of message to be displayed: ERROR_MESSAGE, INFORMATION_MESSAGE, WARNING_MESSAGE, QUESTION_MESSAGE, or PLAIN_MESSAGE
                     // Icon icon, --- the Icon image to display
                     // Object[] selectionValues, --- an array of Objects that gives the possible selections
                     // Object initialSelectionValue) ---  the value used to initialize the input field
    JTextArea textArea = new JTextArea(label);
    JScrollPane scrollPane = new JScrollPane(textArea);  
    textArea.setLineWrap(true);  
    textArea.setWrapStyleWord(true); 
    scrollPane.setPreferredSize(new Dimension(300, 200));
    String label_aux = showInputDialog(null, scrollPane, "Modify and paste into lower pane", PLAIN_MESSAGE);
    // Object aux = showInputDialog(null, scrollPane, "Modify the text", PLAIN_MESSAGE, null, null, scrollPane);
    // String text_aux = (String) aux;
    //String text_aux = showInputDialog("Please enter new text", scrollPane);
    // if (text_aux == null) exit(); else
    // public static void showMessageDialog(Component parentComponent, Object message)
    // public static void showMessageDialog(Component parentComponent, Object message, String title, int messageType)
    // public static void showMessageDialog(...) throws HeadlessException
      // Component parentComponent, --- Frame in which the dialog is displayed; if null, or if the parentComponent has no Frame, a default Frame is used
      // Object message, --- the Object to display
      // String title, --- the title string for the dialog
      // int messageType, --- type of message to be displayed: ERROR_MESSAGE, INFORMATION_MESSAGE, WARNING_MESSAGE, QUESTION_MESSAGE, or PLAIN_MESSAGE
      // Icon icon) --- icon to display in the dialog that helps the user identify the kind of message that is being displayed
    if (label_aux == null || "".equals(label_aux))
      showMessageDialog(null, "Empty TEXT Input!", "Alert", WARNING_MESSAGE);
    else if (search_node_text(label_aux)!=-1)
      showMessageDialog(null, "TEXT \"" + label_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);
    else {
      JTextArea textArea_2 = new JTextArea(label_aux);
      JScrollPane scrollPane_2 = new JScrollPane(textArea_2);  
      textArea_2.setLineWrap(true);  
      textArea_2.setWrapStyleWord(true); 
      scrollPane_2.setPreferredSize(new Dimension(300, 200));
      showMessageDialog(null, scrollPane_2, "Successfully modified", INFORMATION_MESSAGE);
      // showMessageDialog(null, "TEXT \"" + text_aux + "\" successfully modified!", "Successfully modified", INFORMATION_MESSAGE);
      label=label_aux;
      tooltip.text=label;
    }
  }
    
  public void modify_id() {
    String cur_id = id;
    String id_aux = showInputDialog("Please enter new ID, currently " + cur_id);
    if (id_aux == null || id_aux.equals(""))
      showMessageDialog(null, "Empty ID Input!!!", "Alert", ERROR_MESSAGE);
    else if (search_edge_label_index(id_aux, plot_generation_mode)!=-1) {
      showMessageDialog(null, "WARNING: ID \"" + id_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);
      id=id_aux; tooltip.text=id; label=id;
    } else {
      showMessageDialog(null, "ID \"" + id_aux + "\" successfully added!!!", "Info", INFORMATION_MESSAGE);
      id=id_aux; if (label.equals("NULL")) {tooltip.text=id; label=id;}
    }
  }

  public void draw_labelled_edge() { 
    if (!deleted) {
      int head_index = searchNodeIdIndex(head_id); int tail_index = searchNodeIdIndex(tail_id);
      Node head = nodes[head_index]; Node tail = nodes[tail_index];
      fill(edge_color); stroke(edge_color); strokeWeight(1);// grey filling
      label_coordinates(); 
      if (modality.equals("EDT")) {
        drawExternalLine(tail.x, tail.y, label_x, label_y, diameter_size/2);
        drawExternalArrow(label_x, label_y, head.x, head.y, diameter_size/2);
      } else 
      if (modality.equals("NAV")) {
        Unit u = (Unit) nodes[cur_nav_node_index];
        if (u.id.equals(head.id)) {
          drawExternalLine(tail.x_nav, tail.y_nav, label_x_nav, label_y_nav, diameter_size/2);
          drawExternalArrowDiff(label_x_nav, label_y_nav, head.x_nav, head.y_nav, diameter_size/2, head.w_nav/2);}
        else if (u.id.equals(tail.id)) {
          drawExternalLine(tail.x_nav, tail.y_nav, label_x_nav, label_y_nav, diameter_size/2);
          drawExternalArrowDiff(label_x_nav, label_y_nav, head.x_nav, head.y_nav, head.w_nav/2, diameter_size/2);
        }
      } 
      if (modality.equals("EDT") && select) {fill(select_color); noStroke(); ellipse(label_x, label_y, diameter_size, diameter_size);}
      // *** draw label
      fill(text_color);
      if (modality.equals("EDT")) {
        flex_write_lines_in_box(id, default_font_name, default_font_aspect_ratio, "CENTER", "CENTER", label_x, label_y, diameter_size, diameter_size);
      } else 
      if (modality.equals("NAV")) {
        flex_write_lines_in_box(id, default_font_name, default_font_aspect_ratio, "CENTER", "CENTER", label_x_nav, label_y_nav, diameter_size, diameter_size);
      }  
    }
  }
  
  public void label_coordinates() {
    int head_index = searchNodeIdIndex(head_id); int tail_index = searchNodeIdIndex(tail_id);
    Node head = nodes[head_index]; Node tail = nodes[tail_index];
    if (modality.equals("EDT")) {
      label_x = (tail.x + head.x) / 2;
      label_y = (tail.y + head.y) / 2;
    } else  
    if (modality.equals("NAV")) {
      float angle = atan2(tail.y_nav - head.y_nav, tail.x_nav - head.x_nav);
      label_x_nav = ((tail.x_nav - tail.w_nav*cos(angle)) + (head.x_nav+head.w_nav*cos(angle))) / 2;
      label_y_nav = ((tail.y_nav - tail.h_nav*sin(angle)) + (head.y_nav+head.h_nav*sin(angle))) / 2;
    }   
  }

}

// draw all possible edges (depending on plot generation mode
public void draw_labelled_edges() {
  if (plot_generation_mode.equals("PAINTING")) { 
    for (int i=0; i<i_cur_edge; i++) {
      if (searchStringIndex("PAINTING", edges[i].pg_modes, 0, edges[i].pg_modes.length)!=-1) {// if modes contain PAINTING
        edges[i].draw_labelled_edge();}
    }
  } else if (plot_generation_mode.equals("SCULPTING")) {
    for (int i=0; i<i_cur_edge; i++) {
      if (searchStringIndex("SCULPTING", edges[i].pg_modes, 0, edges[i].pg_modes.length)!=-1) {// if modes contain SCULPTING
        edges[i].draw_labelled_edge();}
    } 
  } else { // MANUAL, TENSION, OR PROPP MODE
    for (int i=0; i<i_cur_edge; i++) {
      if (searchStringIndex("MANUAL", edges[i].pg_modes, 0, edges[i].pg_modes.length)!=-1 || 
          searchStringIndex("TENSION", edges[i].pg_modes, 0, edges[i].pg_modes.length)!=-1 || 
          searchStringIndex("PROPP", edges[i].pg_modes, 0, edges[i].pg_modes.length)!=-1) {edges[i].draw_labelled_edge();}
    } 
  }
}

// create new identifier for tag label on button
public String create_edge_id() { // creates id's (e+number) for edges
  boolean id_ok = false; 
  int increment = 0; String id_aux = "e" + str(i_cur_edge + increment); 
  while (!id_ok) {
    if (search_edge_id_index(id_aux, plot_generation_mode)==-1) {return id_aux;}
    else {increment++;}
  }
  return "NULL";
}

public void create_edge(String head_node_id, String tail_node_id, String _label) {
  int head_index = searchNodeIdIndex(head_node_id); int tail_index = searchNodeIdIndex(tail_node_id); 
  int index = search_edge_head_tail_index(head_index, tail_index, plot_generation_mode); // find the edge index
  if (index!=-1) { // if the edge already exists
    replaceString(plot_generation_mode, "NULL", edges[index].pg_modes, 0, edges[index].pg_modes.length); edges[index].pg_mode_counter++;}
  else {
    String aux_id = create_edge_id();
    edges[i_cur_edge]=new Edge(head_node_id, tail_node_id, aux_id, _label, plot_generation_mode); // create edge
    i_cur_edge++; // increment edge counter
  }
}

public int search_edge_id_index(String id, String pg_mode) {
  // println(id);
  for (int i=0; i<i_cur_edge; i++) {
    if (edges[i].id.equals(id) && !edges[i].deleted && searchStringIndex(pg_mode, edges[i].pg_modes, 0, edges[i].pg_modes.length)!=-1) {return i;}
  }
  return -1;
}

public int search_edge_label_index(String l, String pg_mode) {
  // println(t);
  for (int i=0; i<i_cur_edge; i++) {
    if (edges[i].label.equals(l) && !edges[i].deleted && searchStringIndex(pg_mode, edges[i].pg_modes, 0, edges[i].pg_modes.length)!=-1) {return i;}
  }
  return -1;
}

// search edge index in some pg_mode (if "NULL", any mode)
public int search_edge_head_tail_index(int unitHeadIndex, int unitTailIndex, String pg_mode) {
  Unit head = (Unit) nodes[unitHeadIndex]; Unit tail = (Unit) nodes[unitTailIndex];
  if (pg_mode.equals("NULL")) {
    for (int i=0; i<i_cur_edge; i++) {
      if (edges[i].head_id.equals(head.id) && 
          edges[i].tail_id.equals(tail.id) && 
          !edges[i].deleted) {return i;}
    }
  } else {    
    for (int i=0; i<i_cur_edge; i++) {
      if (edges[i].head_id.equals(head.id) && 
          edges[i].tail_id.equals(tail.id) && 
          !edges[i].deleted && 
          searchStringIndex(pg_mode, edges[i].pg_modes, 0, edges[i].pg_modes.length)!=-1) {return i;}
    }
  }
  return -1;
}
// INTERACTIVITY GLOBAL VARIABLES
int flash_iter=0; // flash iteration
int flash_iter_up=1; // direction tion
// String registry_data = "NULL";
int i_move=-1; 
int i_select_node=-1; 
int i_select_edge=-1; 
boolean select2=false; 
String select_type = "NULL"; // type of current selection
String modality ="INI";
String plot_generation_mode = "MANUAL";
// HELP RECTANGLE
String[] help_lines;
boolean help_b = false;
float help_width, help_height;
int select_color; int select_text_color;
// LAYOUT CONDITIONS
boolean white_page;
// INTERACTIVITY CONDITIONS
boolean display_b = false;
boolean key_ok = false; // true if key is active

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%% INITIALIZATION 
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

String start = "Start a new graph";
String scratch = "from scratch (white page)"; String file = "from text file (one unit per row)"; 
// String init = "Init graph nodes from text file"; 
String load = "Load a saved graph";
String manual = "Manual (default)"; String propp = "Propp categories + tags"; 
String pe_constraints_sculpting = "PRECOND-EFFECT constraints (SCULPTING)"; String pe_constraints_painting = "PRECOND-EFFECT constraints (PAINTING)"; 
String dramatic_arc = "Dramatic arc (tension value)";

rectButton start_button, init_button, load_button, 
           scratch_button, file_button, 
           manual_button, propp_button, constraints_sculpting_button, constraints_painting_button, arc_button;

public void initial_page_setup() { 
  float button_height = 2*default_font_size;
  float start_width = start.length()*default_font_size*default_font_aspect_ratio+margin;
  textAlign(CENTER, CENTER); fill(text_color); textSize(default_font_size); 
  text(start, (width/2-margin-start_width/2)*zoom-xo, (2*height/6-5*default_font_size)*zoom-yo);
  float scratch_width = scratch.length()*default_font_size*default_font_aspect_ratio+margin;
  scratch_button = new rectButton("scratch_button", scratch, 
    (width/2+margin+scratch_width/2)*zoom-xo, (2.5f*height/6-5*default_font_size)*zoom-yo, 
    scratch_width, button_height, color(45, 20, 100), text_color, default_font_size); 
  float file_width = file.length()*default_font_size*default_font_aspect_ratio+margin;
  file_button = new rectButton("file_button", file, 
    (width/2+margin+file_width/2)*zoom-xo, (3*height/6-5*default_font_size)*zoom-yo, 
    file_width, button_height, color(45, 40, 100), text_color, default_font_size);
  //float load_width = load.length()*default_font_size*default_font_aspect_ratio+margin;
  //load_button = new rectButton("load_button", load, 
  //  (width/2-margin-load_width/2)*zoom-xo, (4*height/6-5*default_font_size)*zoom-yo, 
  //  load_width, button_height, color(45, 60, 90), text_color, default_font_size);
  float manual_width = manual.length()*default_font_size*default_font_aspect_ratio+margin;
  manual_button = new rectButton("manual_button", manual, 
    (width/2+margin+manual_width/2)*zoom-xo, (4*height/6-5*default_font_size)*zoom-yo, 
    manual_width, button_height, color(45, 20, 100), text_color, default_font_size); 
  float propp_width = propp.length()*default_font_size*default_font_aspect_ratio+margin;
  propp_button = new rectButton("propp_button", propp, 
    (width/2+margin+propp_width/2)*zoom-xo, (9*height/12-5*default_font_size)*zoom-yo, 
    propp_width, button_height, color(45, 40, 100), text_color, default_font_size);
  //float pe_constraints_sculpting_width = pe_constraints_sculpting.length()*default_font_size*default_font_aspect_ratio+margin;
  //constraints_sculpting_button = new rectButton("constraints_sculpting_button", pe_constraints_sculpting, 
  //  (width/2+margin+pe_constraints_sculpting_width/2)*zoom-xo, (10*height/12-5*default_font_size)*zoom-yo, 
  //  pe_constraints_sculpting_width, button_height, color(45, 60, 90), text_color, default_font_size);
  //float pe_constraints_painting_width = pe_constraints_sculpting.length()*default_font_size*default_font_aspect_ratio+margin;
  //constraints_painting_button = new rectButton("constraints_painting_button", pe_constraints_painting, 
  //  (width/2+3*(margin+pe_constraints_painting_width/2))*zoom-xo, (10*height/12-5*default_font_size)*zoom-yo, 
  //  pe_constraints_painting_width, button_height, color(45, 60, 90), text_color, default_font_size);
  float pe_constraints_painting_width = pe_constraints_sculpting.length()*default_font_size*default_font_aspect_ratio+margin;
  constraints_painting_button = new rectButton("constraints_painting_button", pe_constraints_painting, 
    (width/2+margin+pe_constraints_painting_width/2)*zoom-xo, (10*height/12-5*default_font_size)*zoom-yo, 
    pe_constraints_painting_width, button_height, color(45, 60, 90), text_color, default_font_size);
  float dramatic_arc_width = dramatic_arc.length()*default_font_size*default_font_aspect_ratio+margin;
  arc_button = new rectButton("arc_button", dramatic_arc, 
    (width/2+margin+dramatic_arc_width/2)*zoom-xo, (11*height/12-5*default_font_size)*zoom-yo, 
    dramatic_arc_width, button_height, color(45, 80, 90), text_color, default_font_size);
}

public void initialization_choice() {
  // rectMode(RIGHT);
  // start_button.draw_rectButtonCenter();
  float start_width = start.length()*default_font_size*default_font_aspect_ratio+margin;
  textAlign(CENTER, CENTER); fill(text_color); textSize(default_font_size); 
  text(start, (width/2-margin-start_width/2)*zoom-xo, (2.5f*height/6-5*default_font_size)*zoom-yo);
  scratch_button.draw_rectButtonCenter();
  // init_button.draw_rectButtonCenter();
  file_button.draw_rectButtonCenter();
  float load_width = load.length()*default_font_size*default_font_aspect_ratio+margin;
  textAlign(CENTER, CENTER); fill(text_color); textSize(default_font_size); 
  text(load, (width/2-margin-load_width/2)*zoom-xo, (4*height/6-5*default_font_size)*zoom-yo);
  // load_button.draw_rectButtonCenter();
  manual_button.draw_rectButtonCenter();
  propp_button.draw_rectButtonCenter();
  // constraints_sculpting_button.draw_rectButtonCenter();
  constraints_painting_button.draw_rectButtonCenter();
  arc_button.draw_rectButtonCenter();
}

//// rectButton(String i, String t, float xc, float yc, float xw, float yh, color c)
rectButton nav_edt_button;
String nav_text = "NAV"; String edt_text = "EDT";

public void nav_edt_setup() { // nav/edt button goes on the top-right corner 
  float button_height = top_offset;
  float button_width = right_offset;
  // String[] split_string_into_lines (String s, float line_size)
  String[] lines = split_string_into_lines (nav_text, button_width); 
  float font_size = determine_font_size(lines, default_font_aspect_ratio, button_width, button_height);
  nav_edt_button = new rectButton("nav_edt_button", "NULL", 
    (width - right_offset/2)/zoom-xo, (top_offset/2)/zoom-yo, 
    button_width, button_height, rect_button_color, select_text_color, font_size); 
  lines = split_string_into_lines (edt_text, button_width);
  font_size = determine_font_size(lines, default_font_aspect_ratio, button_width, button_height);
}

//// rectButton(String i, String t, float xc, float yc, float xw, float yh, color c)
rectButton man_prp_ptg_tns_switch_button;
String man_text = "MAN"; String prp_text = "PRP"; String ptg_text = "PTG"; String tns_text = "TNS";

public void man_prp_ptg_tns_setup() { // man/prp/ptg/tns button goes on the bottom-left corner 
  float button_height = top_offset;
  float button_width = right_offset;
  // String[] split_string_into_lines (String s, float line_size)
  String[] lines = split_string_into_lines ("MAN", button_width); 
  float font_size = determine_font_size(lines, default_font_aspect_ratio, button_width, button_height);
  man_prp_ptg_tns_switch_button = new rectButton("man_prp_ptg_tns_switch_button", "MAN", 
    (left_offset/2)/zoom-xo, (top_offset+actual_height+bottom_offset/2)/zoom-yo, 
    button_width, button_height, rect_button_color, select_text_color, font_size); 
}


imgButton sg_button, twine_button, ollama_button, twine_banner_button;;

public void update_flash_iter() { 
  if (flash_iter==0) {flash_iter++; flash_iter_up=1;};
  if (flash_iter==1 && flash_iter_up==1) {flash_iter++;};
  if (flash_iter==1 && flash_iter_up==0) {flash_iter--;};
  if (flash_iter==2 && flash_iter_up==1) {flash_iter++;};
  if (flash_iter==2 && flash_iter_up==0) {flash_iter--;};
  if (flash_iter==3 && flash_iter_up==1) {flash_iter++;};
  if (flash_iter==3 && flash_iter_up==0) {flash_iter--;};
  if (flash_iter==4) {flash_iter--; flash_iter_up=0;};
}

public void flashing_ellipse (float x, float y, float r) {
  update_flash_iter();
  ellipse(x*zoom-xo, y*zoom-yo, r+margin*flash_iter, r+margin*flash_iter);
  // pop.play(); // sound
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%% MOUSE SELECTION
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
class Selection { // class for the selection of entities
  String select_type; // can be node or edge
  int select_index; // index of selection in the set of nodes or edges, respectively
  
  Selection(String t, int i) {
    select_type=t; select_index=i;
  }
}

// select the nearest node or edge label to x,y coordinates
public Selection select_node_or_edge_index_at_min_distance(float x, float y, String type_required) {
  Selection select_aux = new Selection("NULL", -1);
  if (type_required.equals("NODE_OR_EDGE")) {
    // println("selecting node or edge"); //<>//<>//<>//
    if (y > y_credits) {
      float min_distance=size_x+1; 
      for (int i=0; i<i_cur_node; i++) { // for each node, compute the block distance and update min_distance
        if (!nodes[i].deleted) {
          //float diff_x=abs(nodes[i].x - x);  float diff_y=abs(nodes[i].y - y);
          float diff_x=abs(nodes[i].x*zoom+xo - x);  float diff_y=abs(nodes[i].y*zoom+yo - y);
          if ((diff_x + diff_y) < min_distance && (diff_x + diff_y) < diameter_size) { // if min_distance changes
            min_distance = diff_x + diff_y;
            select_aux.select_index=i;  select_aux.select_type="NODE";
          }; // end if min_distance changes
        }; // end if NOT DELETED
      }; // end for
      for (int i=0; i<i_cur_edge; i++) { // for each edge, compute the block distance and update min_distance
        if (!edges[i].deleted && edges[i].is_pg_mode_edge(plot_generation_mode)) {
          edges[i].label_coordinates();
          float diff_x=abs(edges[i].label_x*zoom+xo - x);  float diff_y=abs(edges[i].label_y*zoom+yo - y);
          if ((diff_x + diff_y) < min_distance && (diff_x + diff_y) < diameter_size) {
            min_distance = diff_x + diff_y;
            select_aux.select_index=i;  select_aux.select_type="EDGE";
          }; // end if min_distance changes
        }; // end if NOT DELETED
      }; // end for
      // println("selected type: " + select_aux.select_type + "; selected index " + select_aux.select_index);
    }
  }
  return select_aux;
}

boolean selection_possible = true;
boolean creating_edge = false;

public void node_selection() {
  if (selection_possible) {
    Selection i_select_aux = select_node_or_edge_index_at_min_distance(mouseX, mouseY, "NODE_OR_EDGE"); // select something
    if (i_select_aux.select_type.equals("NODE")) { // if clicking on a node
      if (select_type.equals("NODE")) { // if previous selection is node too
        if (i_select_node!=-1 && creating_edge) { // if no selection 2 and creating an edge (after "e") 
          // hide_all_menus();
          int i_select_node2=i_select_aux.select_index; // SELECT NODE 2, second node
          create_edge(nodes[i_select_node2].id, nodes[i_select_node].id, "NULL");
          // edges[i_cur_edge]=new Edge(nodes[i_select_node2].id, nodes[i_select_node].id, "e"+str(i_cur_edge), "NULL", plot_generation_mode); // create edge
          // i_cur_edge++; // increment edge counter
          // nodes[i_select_node].select1=false; i_select_node=-1; // deselect node 1
          node_deselection();
          select_type="NULL"; creating_edge = false;
        }
      } else // previous selection type is NOT NODE
      if (select_type.equals("NULL")) { // if previous selection is NULL
        if (i_select_node==-1) { // if no node selected before
          i_select_node=i_select_aux.select_index; nodes[i_select_node].select1=true; select_type="NODE"; // SELECT NODE 1, first node
          selection_possible = false;
          story_show_menus();
        }
      } else // previous selection type is NOT NODE and NOT NULL, 
      if (select_type.equals("EDGE")) { // if current selection is EDGE
        edges[i_select_edge].select=false;  // change from edge to node selection
        i_select_node=i_select_aux.select_index; nodes[i_select_node].select1=true; 
        select_type="NODE"; selection_possible = false; 
      } 
    } 
  } // END selection possible
}

public void node_deselection() {
  nodes[i_select_node].select1=false; 
  select_type="NULL";
  i_select_node=-1; 
  selection_possible=true;
}

public void edge_selection() {
  if (selection_possible) {
    Selection i_select_aux = select_node_or_edge_index_at_min_distance(mouseX, mouseY, "NODE_OR_EDGE"); // select something
    if (i_select_aux.select_type.equals("EDGE")) { // current selection is EDGE
      if (select_type.equals("NODE") || select_type.equals("NULL")) { // if previous selection was NODE or NULL
        if (i_select_node!=-1) { // possibly deselect first node
          node_deselection();
        } 
      }
      i_select_edge=i_select_aux.select_index; // select edge
      edges[i_select_edge].select=true; select_type="EDGE"; selection_possible = false;
    } // END current selection is EDGE
  } // END selection possible
}

// select the nearest edge label to x_nav,y_nav coordinates
public int select_edge_index_at_min_distance_nav(float x, float y) {
  float min_distance=size_x+1; int select_aux = -1;
  for (int i=0; i<i_cur_edge; i++) { // for each edge, compute the block distance and update min_distance
    if (!edges[i].deleted) {
      edges[i].label_coordinates();
      float diff_x=abs(edges[i].label_x_nav*zoom+xo - x);  float diff_y=abs(edges[i].label_y_nav*zoom+yo - y);
      if ((diff_x + diff_y) < min_distance && (diff_x + diff_y) < diameter_size) {
        min_distance = diff_x + diff_y;
        select_aux=i; 
      }; // end if min_distance changes
    }; // end if NOT DELETED
  }; // end for
  // println("selected index " + select_aux);
  return select_aux;
}

public void edge_selection_nav() {
  //if (selection_possible) {
    i_select_edge = select_edge_index_at_min_distance_nav(mouseX, mouseY); // select something
    if (i_select_edge!=-1) {
      Edge e = edges[i_select_edge];
      if (searchNodeIdIndex(e.head_id)==cur_nav_node_index) { // predecessor
        cur_nav_node_index = searchNodeIdIndex(e.tail_id);} else
      if (searchNodeIdIndex(e.tail_id)==cur_nav_node_index) { // subsequent
        cur_nav_node_index = searchNodeIdIndex(e.head_id);} 
      // edges[i_select_edge].select=true; select_type="EDGE"; selection_possible = false;
    }
  // } // END selection possible //<>//<>//<>//
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%% KEYBOARD INTERACTION
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
public void generic_graph_keyPressed() {
  if (key == CODED) {
    if (keyCode == UP) {yo=yo+margin; key_ok = true;}
    else if (keyCode == DOWN) {yo=yo-margin; key_ok = true;}
    else if (keyCode == RIGHT) {xo=xo-margin; key_ok = true;}
    else if (keyCode == LEFT) {xo=xo+margin; key_ok = true;}
  } else if (key == ESC) {key = 0; showMessageDialog(null, "Press q to exit!!!", "Alert", ERROR_MESSAGE); key_ok = true;
  } else if (key == '+') {zoom += .03f; key_ok = true;
  } else if (key == '-') {zoom -= .03f; key_ok = true;
  } else if (key == 32) {zoom = 1; xo = width/2; yo = height/2; key_ok = true;
  } else if (key == 'q') {exit(); key_ok = true;
  // ================================
  // ======== CANCEL ================
  // ================================
  } else if (key == 'z') { // z = CANCEL
    if (i_select_tag!=-1 && (select_type.equals("TAG")||select_type.equals("NODE+TAG"))) {i_select_tag=-1;}
    if (i_select_node!=-1 && (select_type.equals("NODE")||select_type.equals("NODE+TAG"))) {
      nodes[i_select_node].select1 = false; i_select_node=-1;}
    if (i_select_edge!=-1 && select_type.equals("EDGE")) {edges[i_select_edge].select = false; i_select_edge=-1;}
    select_type="NULL"; selection_possible = true;  // hide_all_menus(); //tags_checkbox.hide();
    if (help_b) {help_b = false;}
    if (display_b) {display_b = false;}
    key_ok = true;
  // ================================
  // ======== TAGS ==================
  // ================================
  } else if (key=='g') { // add a tag to a node or whole story 
      if (select_type=="NODE" && i_select_node!=-1) {
        // hide_all_menus();
        Node n = nodes[i_select_node];
        n.add_node_tag("NULL"); // the tag will be created
        nodes[i_select_node].select1 = false; node_deselection(); // i_select_node=-1; select_type="NULL"; selection_possible = true; 
      } 
      else if (select_type=="NODE+TAG" && i_select_node!=-1 && i_select_tag!=-1) {
        // hide_all_menus();
        Node n = nodes[i_select_node]; Tag tag = tags[i_select_tag];
        n.add_node_tag(tag.name); 
        nodes[i_select_node].select1 = false; i_select_node=-1; 
        i_select_tag=-1; 
        select_type="NULL"; selection_possible = true; 
      }
      key_ok = true;
  // ================================
  // ======== DELETE ==================
  // ================================
    } else if (key=='d') { // d = DELETE
    if (i_select_node!=-1 && select_type.equals("NODE")) {
      // hide_all_menus(); 
      nodes[i_select_node].delete(); i_select_node=-1; select_type="NULL"; selection_possible = true;}
    else if (i_select_edge!=-1 && select_type.equals("EDGE") && 
             searchStringIndex("PAINTING", edges[i_select_edge].pg_modes, 0, edges[i_select_edge].pg_modes.length)==-1 &&
             searchStringIndex("SCULPTING", edges[i_select_edge].pg_modes, 0, edges[i_select_edge].pg_modes.length)==-1) {
      // hide_all_menus(); 
      edges[i_select_edge].delete(); i_select_edge=-1; select_type="NULL"; selection_possible = true;} 
    // delete the selected tag from the whole story
    else if (i_select_tag!=-1 && select_type.equals("TAG")) {
      // hide_all_menus(); 
      tags[i_select_tag].delete(); i_select_tag=-1; select_type="NULL"; selection_possible = true;} 
    // detach the selected agent from the selected unit
    else if (select_type=="NODE+TAG" && i_select_node!=-1 && i_select_tag!=-1) {
      // hide_all_menus();
      Node n = nodes[i_select_node]; Tag tag = tags[i_select_tag];
      n.delete_node_tag(tag.name); 
      nodes[i_select_node].select1 = false; i_select_node=-1; i_select_tag=-1; select_type="NULL"; selection_possible = true; 
    }
    key_ok = true;
  // ======== TEXT ==================
  } else if (key=='t' && !select_type.equals("NULL")) { // modify the text of the selection
    if (i_select_node!=-1 && select_type.equals("NODE")) {
      // hide_all_menus();
      nodes[i_select_node].modify_text(); // modify the text
      nodes[i_select_node].select1 = false; i_select_node=-1; select_type="NULL"; selection_possible = true; // unselect
    } else if (select_type=="TAG" && i_select_tag!=-1) {
        // hide_all_menus();
        tags[i_select_tag].modify_name(); // modify the text
        i_select_tag=-1; select_type="NULL"; selection_possible = true; // unselect
    }
  //} else if (key=='g') { // modify the tags of the selected node
  //  if (i_select_node!=-1 && select_type.equals("NODE")) {
  //    nodes[i_select_node].modify_tags(); // modify the tags through the checkbox
  //    nodes[i_select_node].select1 = false; i_select_node=-1; select_type="NULL"; selection_possible = true; // unselect
  //  }
    key_ok = true;
  } else if (key=='h') { // display help
    if (!help_b) {
      help_b = true;
      display_help(); 
    }
    key_ok = true;
  } else if (key=='i' && !select_type.equals("NULL")) { // modify the identifier of the selected node
    if (i_select_node!=-1 && select_type.equals("NODE")) {
      // hide_all_menus();
      nodes[i_select_node].modify_id(); 
      nodes[i_select_node].select1 = false; i_select_node=-1; select_type="NULL"; selection_possible = true;
    } else if (i_select_edge!=-1 && select_type.equals("EDGE")){ 
      edges[i_select_edge].modify_id(); 
      edges[i_select_edge].select = false; i_select_edge=-1; select_type="NULL"; selection_possible = true;
    }
    key_ok = true;
  } else if (key=='e') { // create an edge between the selected nodes
    if (i_select_node!=-1) {
      // hide_all_menus(); 
      selection_possible = true; creating_edge = true;
    }
  //} else if (key=='f') { // associate an image with a node
  //  if (i_select_node!=-1) {
  //    selectInput("Select an image file:", "load_image_in_selected_node");
  //  }  
    key_ok = true;
  //} else if (key=='v') { // display an image with a node
  //  if (modality.equals("EDT") && i_select_node!=-1) {
  //    display_b = true;
  //    nodes[i_select_node].display_image();
  //    // hide_all_menus(); 
  //    nodes[i_select_node].select1 = false; i_select_node=-1; select_type="NULL"; selection_possible = true;
  //  } else if (modality.equals("NAV")) {
  //    display_b = true;      
  //    nodes[cur_nav_node_index].display_image();
  //  }
  //  key_ok = true;
  //} else if (key=='n') { // create a new node 
  //  if (i_select_node==-1) {
  //    nodes[i_cur_node]=new Node(0, 0, diameter_size, diameter_size, "N" + str(hour()) + str(minute()) + str(second()) + node_counter++, "NULL", "NULL");                                          
  //    i_cur_node++;
  //  }
  //  key_ok = true;
  } else if (key=='l') { // insert a new label for an edge
    if (i_select_edge!=-1 && select_type.equals("EDGE")) {
      edges[i_select_edge].modify_label(); 
      edges[i_select_edge].select = false; i_select_edge=-1; select_type="NULL"; selection_possible=true;
    }
    key_ok = true;
  // ========= MOVE A NODE =============
  } else if (key=='m' && !select_type.equals("NULL")) { // move something
    // hide_all_menus();
    i_move=-1; Node i_move_node= null; // node selected to move
    if (i_select_node!=-1 && select_type.equals("NODE") && mousePressed) { 
      if (mouseX > x_credits && mouseX < x_credits+top_offset && mouseY > y_credits && mouseY < y_credits+top_offset) {
        i_move = -1; // CREDITS
      } else {
        i_move = i_select_node; i_move_node=nodes[i_move]; // cp5.hide(); // tags_checkbox.hide(); // tags_checkbox.deactivateAll();
        i_move_node.x= mouseX/zoom-xo; i_move_node.y= mouseY/zoom-yo;
      }
    }; // end if mousePressed  
    if (i_move_node!=null) {
      flashing_ellipse (i_move_node.x, i_move_node.y, i_move_node.w);
    }
    key_ok = true;
  }
  
}

public void load_image_in_selected_node(File selected_image_file) {
  println("i_select_node = " + i_select_node);
  nodes[i_select_node].modify_image(selected_image_file.getAbsolutePath());
  // hide_all_menus(); 
  nodes[i_select_node].select1 = false; i_select_node=-1; select_type="NULL"; selection_possible = true;
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%% DISPLAY HELP 
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

public void help_settings() {
  // help_lines = loadStrings("commands.txt");
  help_width = (size_x/2)/zoom; help_height = (size_x/2)/zoom;
}

public void display_help() {
  if (help_b) {
    imageMode(CENTER); image(sg_menu, width/2-xo, height/2-yo); //, sg_logo.width*2*y_credits/sg_logo.height, 2*y_credits);
    /*
    fill(0,0,100,200); rectMode(CENTER);
    rect((size_x/2)/zoom-xo, (size_y/2)/zoom-yo, width, height);
    fill(0,0,100); rectMode(CENTER);
    rect((size_x/2)/zoom-xo, (size_y/2)/zoom-yo, help_width, help_height);
    float x = ((size_x/2)/zoom-xo) - help_width/2;
    float y_base = (size_y/2)/zoom-yo - help_height/2;
    text_settings(); 
    for (int i=0; i<help_lines.length;i++) {
      fill(0,0,0); textAlign(LEFT,TOP);
      text(help_lines[i], x, y_base+i*default_font_size); //, help_width, default_font_size);
      //flex_write_lines_in_box(help_lines[i], default_font_name, default_font_aspect_ratio, 
        //                      "LEFT", "CENTER", x, y_base+i*default_font_size, help_width, default_font_size);
    }
    */
  }
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%% DISPLAY CREDITS 
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

public void display_credits() {
  // rectMode(CENTER); 
  fill(180,100,100);
  rect(size_x/2, size_y/2, size_x/2, size_y/5);
  fill(0); textAlign(CENTER,CENTER); textFont(default_font_type, 12);
  text("Dynamic and interactive graph \n design by VL, CC(4.0) license \n pop sound by DannyBro, freesound.org, CC(0) license", size_x/2, size_y/2);
  
}


// Declare the main DashedLines object
DashedLines dash;

// LAYOUT GLOBAL VARIABLES
int size_x= 1280; // 640; //  1280; 960; 1280;
int size_y= 760; // 380; // 760; 570;
float margin = 5; // margin for separation of graphical objects
float left_offset = size_x/20; // 64
float right_offset = size_x/20; 
float top_offset = size_y/20; // 38
float bottom_offset = size_y/20; 
float actual_width = size_x - (left_offset+right_offset); // 1152
float actual_height = size_y - (top_offset+bottom_offset); // 684
float title_width = actual_width - 2*(left_offset+right_offset);
float title_height = top_offset;
float x_credits = size_x/2; 
float y_credits = top_offset;
// TRANSLATE AND ZOOM
float xo=0;
float yo=0;
float zoom = 1;
// COLORS
int global_bg_color = color(0, 0, 0); 
int bg_color_1 = color(0, 0, 0);
int bg_color_2 = color(0, 0, 0);
// NAVIGATION
int cur_nav_node_index = -1;


// DRAWING AUXILIARY FUNCTIONS 
public void generic_layout_settings() {
  size(size_x, size_y); // size of the display window
  diameter_size = size_x/30;
  cur_node_size_in_nav = size_x/3;
  xo = width/2;
  yo = height/2;
}

public void color_setup() {
  colorMode(HSB, 360, 100, 100);
  node_color = color(0, 0, 100); edge_color = color(0, 0, 0); text_color = color(0, 0, 0);
  select_color = color(0,0,0); // color(0,0,70); // 33); // black
  select_text_color = color(255); // white
  global_bg_color = color(0, 0, 100); // HSV white
  bg_color_1 = color(45, 20, 100); // HSV insature yellow
  bg_color_2 = color(45, 60, 100); // HSV avg sature yellow
  rect_button_color = color(0); 
}

// HEADER
public void draw_header() {
  int s = (int) top_offset-2; textSize(s); textFont(default_font_type, s); 
  
  sg_button.draw_imgButtonCenter(); 
  twine_button.draw_imgButtonCenter();
  ollama_button.draw_imgButtonCenter();
  // twine_banner_button.draw_imgButtonCenter();
  
  line((x_credits-(graph_name.length()/2)*default_font_aspect_ratio*s)/zoom-xo, top_offset/zoom-yo, 
       (x_credits+(graph_name.length()/2)*default_font_aspect_ratio*s)/zoom-xo, top_offset/zoom-yo);
  textAlign(CENTER,DOWN); fill(text_color);
  // text(graph_name, x_credits/zoom-xo, y_credits/zoom-yo);
  flex_write_lines_in_box(graph_name, default_font_name, default_font_aspect_ratio, "CENTER", "DOWN", x_credits/zoom-xo, y_credits/zoom-yo, title_width, title_height);
  nav_edt_button.draw_rectButtonCenter();
  // if (modality.equals("EDT")) {nav_edt_button.draw_rectButtonCenter();} else 
  // if (modality.equals("NAV")) {nav_edt_button.draw_rectButtonCenter();} 
}

public void draw_footer() {
  if (modality.equals("EDT")) {
    man_prp_ptg_tns_switch_button.draw_rectButtonCenter();
  }
}

public String set_graph_name() {
  String name = showInputDialog("Please enter a name for the graph");
  if (name == null || name.equals("")) {
    showMessageDialog(null, "Empty name!!!", "Alert", ERROR_MESSAGE);
    // name = set_graph_name();
    name = "NULL";
  }
  return name;
}


// EDGE DRAWING AUXILIARY FUNCTIONS

// by ketakahashi @ https://gist.github.com/ketakahashi/81b7f22b4ecee1fa5d84393ab670ef99
public void drawArrow(float x1, float y1, float x2, float y2) { 
  float a = dist(x1, y1, x2, y2) / 50;
  pushMatrix();
  translate(x2, y2);
  rotate(atan2(y2 - y1, x2 - x1));
  triangle(-a * 2, -a, 0, 0, - a * 2, a);
  popMatrix();
  line(x1, y1, x2, y2);  
}

// draws external arrow between two circles of same size
public void drawExternalArrow(float x1, float y1, float x2, float y2, float r) { 
  float angle = atan2(y2 - y1, x2 - x1);
  // float a = dist(x1, y1, x2, y2) / 50;
  // float a = dist(x1, y1, x2-r * cos(angle), y2-r * sin(angle)) / 50;
  float a = height/150;
  // build the tip of the arrow (triangle in the arrow direction)
  pushMatrix();
  // translate(x2, y2);
  translate(x2-(r*cos(angle)), y2-(r*sin(angle)));
  rotate(angle);
  triangle(-a * 2, -a, 0, 0, -a * 2, a);
  popMatrix();
  line(x1+r*cos(angle), y1+r*sin(angle), x2-(r*cos(angle)), y2-(r*sin(angle)));  
}

// draws external arrow between two circles of different sizes
public void drawExternalArrowDiff(float x1, float y1, float x2, float y2, float r1, float r2) { 
  float angle = atan2(y2 - y1, x2 - x1);
  // float a = dist(x1, y1, x2, y2) / 50;
  // float a = dist(x1, y1, x2-r * cos(angle), y2-r * sin(angle)) / 50;
  float a = height/150;
  // build the tip of the arrow (triangle in the arrow direction)
  pushMatrix();
  // translate(x2, y2);
  translate(x2-(r2*cos(angle)), y2-(r2*sin(angle)));
  rotate(angle);
  triangle(-a * 2, -a, 0, 0, -a * 2, a);
  popMatrix();
  line(x1+r1*cos(angle), y1+r1*sin(angle), x2-(r2*cos(angle)), y2-(r2*sin(angle)));  
}

// draws external line from a circle
public void drawExternalLine(float x1, float y1, float x2, float y2, float r) { 
  float angle = atan2(y2 - y1, x2 - x1);
  line(x1+r*cos(angle), y1+r*sin(angle), x2-(r*cos(angle)), y2-(r*sin(angle)));  
}

public float check_horizontal_boundaries(float x, float x_width) {
  float bx = x;
  if (bx*zoom+xo < left_offset){bx = left_offset/zoom-xo;} 
  if ((bx+x_width/2)*zoom+xo > left_offset+actual_width){bx = ((left_offset+actual_width)-x_width/2)/zoom-xo;} 
  return bx;
}

public float check_vertical_boundaries(float y, float y_height) {
  float by = y;
  if ((by-y_height/2)*zoom+yo < top_offset) {by = (top_offset+y_height/2)/zoom-yo;} else
  if ((by+y_height/2)*zoom+yo > top_offset+actual_height) {by = ((top_offset+actual_height)-y_height/2)/zoom-yo;} 
  return by;
}
///**
// * ControlP5 Checkbox
// * an example demonstrating the use of a checkbox in controlP5. 
// * CheckBox extends the RadioButton class.
// * to control a checkbox use: 
// * activate(), deactivate(), activateAll(), deactivateAll(), toggle(), getState()
// *
// * find a list of public methods available for the Checkbox Controller 
// * at the bottom of this sketch's source code
// *
// * by Andreas Schlegel, 2012
// * www.sojamo.de/libraries/controlP5
// *
// */

//import controlP5.*; // library for menus (mostly checkboxes used here)

//ControlP5 cp5; // major class for menus

//int spacing_row = 2;
//float item_width = size_x/30;
//float item_height; // = default_font_size;

//CheckBox tags_checkbox; // checkbox for tags (related to nodes)
//int i_cur_tag_checkbox = 0; // counter for tag items in the checkbox
//String[] cur_node_tags_from_checkbox; // current tags for the currently selected node

//void menu_checkbox_setup() {
//  cp5 = new ControlP5(this);
//  item_height = default_font_size;
//  tags_checkbox_setup();
//  propp_checkbox_setup();
//  state_checkbox_setup();
//  tensions_checkbox_setup();
//}

//void tags_checkbox_setup() {
//  tags_checkbox = cp5.addCheckBox("checkBox")                
//                .setPosition(0, 0)
//                .setColorForeground(color(0, 50, 100)) // light red
//                .setColorActive(color(60, 50, 100)) // light yellow
//                .setColorLabel(color(0, 0, 0)) // black for label
//                .setSize(int(item_width), int(item_height))
//                .setItemsPerRow(1)
//                //.setSpacingColumn(30)
//                .setSpacingRow(spacing_row)
//                .hide();
//                //.deactivateAll();
//  // tags_checkbox.addItem("NEW TAG", 0);
//  // i_cur_tag_checkbox = 0;
//  // all nodes are tagged with a list of NULL TAGs
//  cur_node_tags_from_checkbox = new String[total_tags];
//  for (int i=0; i<total_tags; i++) {cur_node_tags_from_checkbox[i]="NULL TAG";}
//}

//CheckBox propp_checkbox;

//void propp_checkbox_setup() {
//  // println("propp checkbox setup"); 
//  propp_checkbox = cp5.addCheckBox("proppBox")                
//                .setPosition(0, 0)
//                .setColorForeground(color(0, 50, 100)) // light red
//                .setColorActive(color(60, 50, 100)) // light yellow
//                .setColorLabel(color(0, 0, 0)) // black for label
//                .setSize(int(size_x/30), int(default_font_size))
//                .setItemsPerRow(1)
//                //.setSpacingColumn(30)
//                .setSpacingRow(spacing_row)
//                .hide();
//                // .deactivateAll();
//  for (int i=0; i<propp_tooltips.length; i++) {
//    propp_checkbox.addItem(proppIds[i], i);
//    // propp_checkbox.addItem(proppTags[i], i);
//    // print (propp_checkbox.getItem(i).getName() + " ");
//    propp_checkbox.getItem(i).getCaptionLabel().alignX(RIGHT)._myPaddingX=propp_checkbox.getItem(i).getWidth();
//  }
//}


//CheckBox preconditions_checkbox, effects_checkbox;
//int i_cur_preconditions_checkbox=0; int i_cur_effects_checkbox=0;
//// int i_cur_states_checkbox=0;
//String[] cur_unit_preconditions_from_checkbox;
//String[] cur_unit_effects_from_checkbox;
//// String[] cur_unit_states_from_checkbox;

//void state_checkbox_setup() {
//  i_cur_preconditions_checkbox=0; i_cur_effects_checkbox=0;
//  preconditions_checkbox = cp5.addCheckBox("preconditionsBox")                
//                .setPosition(0, 0)
//                .setColorForeground(color(0, 50, 100)) // light red
//                .setColorActive(color(60, 50, 100)) // light yellow
//                .setColorLabel(color(0, 0, 0)) // black for label
//                .setSize(int(size_x/30), int(default_font_size))
//                .setItemsPerRow(1)
//                //.setSpacingColumn(30)
//                .setSpacingRow(spacing_row)
//                .hide();
//                //.deactivateAll();
//  effects_checkbox = cp5.addCheckBox("effectsBox")                
//                .setPosition(0, 0)
//                .setColorForeground(color(0, 50, 100)) // light red
//                .setColorActive(color(60, 50, 100)) // light yellow
//                .setColorLabel(color(0, 0, 0)) // black for label
//                .setSize(int(size_x/30), int(default_font_size))
//                .setItemsPerRow(1)
//                //.setSpacingColumn(30)
//                .setSpacingRow(spacing_row)
//                .hide();
//                //.deactivateAll();
//  // preconditions_checkbox.addItem("NEW PRECOND", i_cur_preconditions_checkbox); 
//  // preconditions_checkbox.getItem(i_cur_preconditions_checkbox).getCaptionLabel().alignX(RIGHT)._myPaddingX=preconditions_checkbox.getItem(i_cur_preconditions_checkbox).getWidth();
//  // i_cur_preconditions_checkbox++;
//  // effects_checkbox.addItem("NEW EFFECT", i_cur_effects_checkbox++);
//  // i_cur_state_checkbox = 0; // USELESS???
//  cur_unit_preconditions_from_checkbox = new String[total_states];
//  cur_unit_effects_from_checkbox = new String[total_states]; 
//  for (int i=0; i<total_states; i++) {
//    cur_unit_preconditions_from_checkbox[i]="NULL STATE"; 
//    cur_unit_effects_from_checkbox[i]="NULL STATE";
//  }
//}

//CheckBox tensions_checkbox; // checkbox for tensions (related to nodes)
//int i_cur_tension_checkbox = 0; // counter for tension items in the checkbox
//String[] cur_node_tensions_from_checkbox; // current tensions for the currently selected node

//void tensions_checkbox_setup() {
//  tensions_checkbox = cp5.addCheckBox("checkBox")                
//                      .setPosition(0, 0)
//                      .setColorForeground(color(0, 50, 100)) // light red
//                      .setColorActive(color(60, 50, 100)) // light yellow
//                      .setColorLabel(color(0, 0, 0)) // black for label
//                      .setSize(int(size_x/30), int(default_font_size)) // default_font_size == 12 
//                      .setItemsPerRow(1)
//                      //.setSpacingColumn(30)
//                      .setSpacingRow(spacing_row)
//                      .hide();
//                       //.deactivateAll();
//  cur_node_tensions_from_checkbox = new String[total_tensions];
//  for (int i=0; i<total_tensions; i++) {
//    cur_node_tensions_from_checkbox[i]="NULL TENSION";
//  }
//}

//boolean unique_event = true;

//void controlEvent(ControlEvent theEvent) {
//  // ============================================================================
//  // ==========================  TAGS  ====================================
//  // ============================================================================
//  if (theEvent.isFrom(tags_checkbox)) {
//    print("got an event from "+tags_checkbox.getName()+"\t\n");
//    print4check("cur_node_tags_from_checkbox: ", 0, 10, cur_node_tags_from_checkbox);
//    initialize_tag_list(cur_node_tags_from_checkbox); 
//    print4check("cur_node_tags_from_checkbox: ", 0, 10, cur_node_tags_from_checkbox);
//    if (unique_event) {
//      unique_event = false;
//      int counter = 0; int number_of_items = tags_checkbox.getItems().size();
//      for (int j=0; j<number_of_items; j++) {
//        if (tags_checkbox.getItem(j).getState()) {
//          print("got one true state "+tags_checkbox.getItem(j).getName()+"\t\n");
//          // if (tags_checkbox.getItem(j).getName().equals("NEW TAG")) {
//            // cur_node_tags_from_checkbox[counter++] = create_tag();
//            // tags_checkbox.getItem(j).setState(false);
//          // } else {
//            cur_node_tags_from_checkbox[counter++] = tags_checkbox.getItem(j).getName();
//          // }
//        }
//      }
//    }
//    unique_event = true;
//  } // END event from tag_checkbox
//  // ============================================================================
//  // ==========================  TENSION  ====================================
//  // ============================================================================
//  else if (theEvent.isFrom(tensions_checkbox)) {
//    //print("got an event from "+tensions_checkbox.getName()+"\t\n");
//    if (unique_event) {
//      unique_event = false;
//      int number_of_items = tensions_checkbox.getItems().size(); 
//      int new_tension_index = -1; 
//      if (i_select_node!=-1) {
//        Unit u = (Unit) nodes[i_select_node]; 
//        if (u.unit_tension_name.equals("NULL")) { // if current tension name is NULL
//          for (int j=0; j<number_of_items; j++) { // for each item of tension checkbox
//            if (tensions_checkbox.getItem(j).getState()) {cur_unit_tension_index=j;} // set old index to j, if j true
//          }
//        } else { // if current unit tension name is NOT "NULL"
//          for (int j=0; j<number_of_items; j++) { // for each item of tension checkbox
//            // if true and not coincident with current, save the new one
//            if (tensions_checkbox.getItem(j).getState() && cur_unit_tension_index!=j) {new_tension_index = j;}
//          }
//          if (new_tension_index!=-1) { // if a new one exists
//            tensions_checkbox.getItem(cur_unit_tension_index).setState(false); // unselect the current
//          }
//          cur_unit_tension_index = new_tension_index; // set current to new one (possibly -1)
//        }
//      }
//    }
//    unique_event = true;
//  } // END event from tensions_checkbox
//  // ============================================================================
//  // ==========================  PROPP  ====================================
//  // ============================================================================
//  else if (theEvent.isFrom(propp_checkbox)) {
//    //print("got an event from "+propp_checkbox.getName()+"\t\n");
//    if (unique_event) {
//      unique_event = false;
//      int number_of_items = propp_checkbox.getItems().size(); int new_propp_tag = -1; 
//      if (cur_unit_propp_tag_index == -1) { // if current propp index is null (-1)
//        for (int j=0; j<number_of_items; j++) { // for each item of propp checkbox
//          if (propp_checkbox.getItem(j).getState()) {cur_unit_propp_tag_index=j;} // set current j
//        }
//      } else { // if current propp index is NOT null (some index)
//        for (int j=0; j<number_of_items; j++) { // for each item of propp checkbox
//          // if true and not coincident with current, save the new one
//          if (propp_checkbox.getItem(j).getState() && cur_unit_propp_tag_index!=j) {new_propp_tag = j;}
//        }
//        if (new_propp_tag!=-1) { // if a new one exists
//          propp_checkbox.getItem(cur_unit_propp_tag_index).setState(false); // unselect the current
//          cur_unit_propp_tag_index = new_propp_tag; // set current to new one
//        }
//        else {cur_unit_propp_tag_index = -1;}
//      }
//    }
//    unique_event = true;
//  } // END event from propp_checkbox
//  // ============================================================================
//  // ========================  PRECONDITIONS  ===================================
//  // ============================================================================
//  else if (theEvent.isFrom(preconditions_checkbox)) {
//    if (unique_event) {
//      unique_event = false;
//      initialize_state_list(cur_unit_preconditions_from_checkbox);
//      print("got an event from "+preconditions_checkbox.getName()+"\t\n");
//      int counter = 0; int number_of_items = preconditions_checkbox.getItems().size();
//      // print("number_of_items = "+number_of_items+"\t\n");
//      for (int j=0; j<number_of_items; j++) {
//        if (preconditions_checkbox.getItem(j).getState()) {
//          // if (preconditions_checkbox.getItem(j).getName().equals("NEW PRECOND")) { // OBSOLETE CODE: NOW CREATION WITH 's'
//            // cur_unit_preconditions_from_checkbox[counter] = create_state();
//            // preconditions_checkbox.getItem(j).setState(false); // turn NEW PRECOND back to false
//            // cur_unit_effects_from_checkbox[counter] = cur_unit_preconditions_from_checkbox[counter];
//            // effects_checkbox.getItem(j).setState(false);
//            // counter++;
//          // } else {
//            cur_unit_preconditions_from_checkbox[counter] = preconditions_checkbox.getItem(j).getName();
//            print("updated "+cur_unit_preconditions_from_checkbox[counter]);
//            counter++;
//          // }
//        }
//      }
//    }
//    unique_event = true;
//  } // END event from preconditions_checkbox
//  // ============================================================================
//  // ==========================  EFFECTS  ====================================
//  // ============================================================================
//  else if (theEvent.isFrom(effects_checkbox)) {
//    if (unique_event) {
//      unique_event = false;
//      initialize_state_list(cur_unit_effects_from_checkbox);
//      print("got an event from "+effects_checkbox.getName()+"\t\n");
//      int counter = 0; int number_of_items = effects_checkbox.getItems().size();
//      // print("number_of_items = "+number_of_items+"\t\n");
//      for (int j=0; j<number_of_items; j++) {
//        if (effects_checkbox.getItem(j).getState()) {
//          // if (effects_checkbox.getItem(j).getName().equals("NEW EFFECT")) {
//            // cur_unit_effects_from_checkbox[counter++] = create_state();
//            // effects_checkbox.getItem(j).setState(false);
//            // cur_unit_preconditions_from_checkbox[counter] = cur_unit_effects_from_checkbox[counter];
//            // preconditions_checkbox.getItem(j).setState(false);
//          // } else {
//            cur_unit_effects_from_checkbox[counter] = effects_checkbox.getItem(j).getName();
//            counter++;
//          // }
//        }
//      }
//    }
//    unique_event = true;
//  } // END event from effects_checkbox

//  // println("exiting controlEvent");    
//}

//// function that hides all menus (checkboxes)
//void // hide_all_menus() {
//  tags_checkbox.hide();
//  propp_checkbox.hide();
//  preconditions_checkbox.hide();
//  effects_checkbox.hide();
//  tensions_checkbox.hide();
//}

//void checkBox(float[] a) {
//  println(a);
//}


///*
//a list of all methods available for the CheckBox Controller
//use ControlP5.printPublicMethodsFor(CheckBox.class);
//to print the following list into the console.

//You can find further details about class CheckBox in the javadoc.

//Format:
//ClassName : returnType methodName(parameter type)


//controlP5.CheckBox : CheckBox addItem(String, float) 
//controlP5.CheckBox : CheckBox addItem(Toggle, float) 
//controlP5.CheckBox : CheckBox deactivateAll() 
//controlP5.CheckBox : CheckBox hideLabels() 
//controlP5.CheckBox : CheckBox removeItem(String) 
//controlP5.CheckBox : CheckBox setArrayValue(float[]) 
//controlP5.CheckBox : CheckBox setColorLabels(int) 
//controlP5.CheckBox : CheckBox setImage(PImage) 
//controlP5.CheckBox : CheckBox setImage(PImage, int) 
//controlP5.CheckBox : CheckBox setImages(PImage, PImage, PImage) 
//controlP5.CheckBox : CheckBox setItemHeight(int) 
//controlP5.CheckBox : CheckBox setItemWidth(int) 
//controlP5.CheckBox : CheckBox setItemsPerRow(int) 
//controlP5.CheckBox : CheckBox setNoneSelectedAllowed(boolean) 
//controlP5.CheckBox : CheckBox setSize(PImage) 
//controlP5.CheckBox : CheckBox setSize(int, int) 
//controlP5.CheckBox : CheckBox setSpacingColumn(int) 
//controlP5.CheckBox : CheckBox setSpacingRow(int) 
//controlP5.CheckBox : CheckBox showLabels() 
//controlP5.CheckBox : String getInfo() 
//controlP5.CheckBox : String toString() 
//controlP5.CheckBox : Toggle getItem(int)
//controlP5.CheckBox : List getItems()
//controlP5.CheckBox : boolean getState(String) 
//controlP5.CheckBox : boolean getState(int) 
//controlP5.CheckBox : void updateLayout() 
//controlP5.ControlGroup : CheckBox activateEvent(boolean) 
//controlP5.ControlGroup : CheckBox addListener(ControlListener) 
//controlP5.ControlGroup : CheckBox hideBar() 
//controlP5.ControlGroup : CheckBox removeListener(ControlListener) 
//controlP5.ControlGroup : CheckBox setBackgroundColor(int) 
//controlP5.ControlGroup : CheckBox setBackgroundHeight(int) 
//controlP5.ControlGroup : CheckBox setBarHeight(int) 
//controlP5.ControlGroup : CheckBox showBar() 
//controlP5.ControlGroup : CheckBox updateInternalEvents(PApplet) 
//controlP5.ControlGroup : String getInfo() 
//controlP5.ControlGroup : String toString() 
//controlP5.ControlGroup : boolean isBarVisible() 
//controlP5.ControlGroup : int getBackgroundHeight() 
//controlP5.ControlGroup : int getBarHeight() 
//controlP5.ControlGroup : int listenerSize() 
//controlP5.ControllerGroup : CColor getColor() 
//controlP5.ControllerGroup : CheckBox add(ControllerInterface) 
//controlP5.ControllerGroup : CheckBox bringToFront() 
//controlP5.ControllerGroup : CheckBox bringToFront(ControllerInterface) 
//controlP5.ControllerGroup : CheckBox close() 
//controlP5.ControllerGroup : CheckBox disableCollapse() 
//controlP5.ControllerGroup : CheckBox enableCollapse() 
//controlP5.ControllerGroup : CheckBox hide() 
//controlP5.ControllerGroup : CheckBox moveTo(ControlWindow) 
//controlP5.ControllerGroup : CheckBox moveTo(PApplet) 
//controlP5.ControllerGroup : CheckBox open() 
//controlP5.ControllerGroup : CheckBox registerProperty(String) 
//controlP5.ControllerGroup : CheckBox registerProperty(String, String) 
//controlP5.ControllerGroup : CheckBox remove(CDrawable) 
//controlP5.ControllerGroup : CheckBox remove(ControllerInterface) 
//controlP5.ControllerGroup : CheckBox removeCanvas(ControlWindowCanvas) 
//controlP5.ControllerGroup : CheckBox removeProperty(String) 
//controlP5.ControllerGroup : CheckBox removeProperty(String, String) 
//controlP5.ControllerGroup : CheckBox setAddress(String) 
//controlP5.ControllerGroup : CheckBox setArrayValue(float[]) 
//controlP5.ControllerGroup : CheckBox setColor(CColor) 
//controlP5.ControllerGroup : CheckBox setColorActive(int) 
//controlP5.ControllerGroup : CheckBox setColorBackground(int) 
//controlP5.ControllerGroup : CheckBox setColorForeground(int) 
//controlP5.ControllerGroup : CheckBox setColorLabel(int) 
//controlP5.ControllerGroup : CheckBox setColorValue(int) 
//controlP5.ControllerGroup : CheckBox setHeight(int) 
//controlP5.ControllerGroup : CheckBox setId(int) 
//controlP5.ControllerGroup : CheckBox setLabel(String) 
//controlP5.ControllerGroup : CheckBox setMouseOver(boolean) 
//controlP5.ControllerGroup : CheckBox setMoveable(boolean) 
//controlP5.ControllerGroup : CheckBox setOpen(boolean) 
//controlP5.ControllerGroup : CheckBox setPosition(PVector) 
//controlP5.ControllerGroup : CheckBox setPosition(float, float) 
//controlP5.ControllerGroup : CheckBox setStringValue(String) 
//controlP5.ControllerGroup : CheckBox setUpdate(boolean) 
//controlP5.ControllerGroup : CheckBox setValue(float) 
//controlP5.ControllerGroup : CheckBox setVisible(boolean) 
//controlP5.ControllerGroup : CheckBox setWidth(int) 
//controlP5.ControllerGroup : CheckBox show() 
//controlP5.ControllerGroup : CheckBox update() 
//controlP5.ControllerGroup : CheckBox updateAbsolutePosition() 
//controlP5.ControllerGroup : ControlWindow getWindow() 
//controlP5.ControllerGroup : ControlWindowCanvas addCanvas(ControlWindowCanvas) 
//controlP5.ControllerGroup : Controller getController(String) 
//controlP5.ControllerGroup : ControllerProperty getProperty(String) 
//controlP5.ControllerGroup : ControllerProperty getProperty(String, String) 
//controlP5.ControllerGroup : Label getCaptionLabel() 
//controlP5.ControllerGroup : Label getValueLabel() 
//controlP5.ControllerGroup : PVector getPosition() 
//controlP5.ControllerGroup : String getAddress() 
//controlP5.ControllerGroup : String getInfo() 
//controlP5.ControllerGroup : String getName() 
//controlP5.ControllerGroup : String getStringValue() 
//controlP5.ControllerGroup : String toString() 
//controlP5.ControllerGroup : Tab getTab() 
//controlP5.ControllerGroup : boolean isCollapse() 
//controlP5.ControllerGroup : boolean isMouseOver() 
//controlP5.ControllerGroup : boolean isMoveable() 
//controlP5.ControllerGroup : boolean isOpen() 
//controlP5.ControllerGroup : boolean isUpdate() 
//controlP5.ControllerGroup : boolean isVisible() 
//controlP5.ControllerGroup : boolean setMousePressed(boolean) 
//controlP5.ControllerGroup : float getValue() 
//controlP5.ControllerGroup : float[] getArrayValue() 
//controlP5.ControllerGroup : int getHeight() 
//controlP5.ControllerGroup : int getId() 
//controlP5.ControllerGroup : int getWidth() 
//controlP5.ControllerGroup : void remove() 
//java.lang.Object : String toString() 
//java.lang.Object : boolean equals(Object) 


//*/
// GRAPH NODES: GLOBAL VARIABLES
int totalNum; 
// int num = 0; 
// int num_deleted = 0;
Node[] nodes; // array of nodes
int i_cur_node = 0; // cursor on nodes
int node_counter = 0;
// int[] deleted_nodes; // nodes deleted in one session
float diameter_size; 
float cur_node_size_in_nav;
int node_color;
// NAV variables
String[] predecessor_node_ids; // predecessor node ids of the current node in NAV mode
String[] subsequent_node_ids; // subsequent nodes of the current node in NAV mode
int i_cur_predecessor; int i_cur_subsequent; // total of predecessor and subsequent, respectively

public void generic_graph_settings() {
  totalNum = 1000; 
  total_num_edges=totalNum^2;
  nodes = new Node[totalNum];
  edges = new Edge[total_num_edges];
  // deleted_nodes = new int[totalNum]; 
  predecessor_node_ids = new String[totalNum]; i_cur_predecessor=-1;
  subsequent_node_ids = new String[totalNum]; i_cur_subsequent=-1;
}

public void generic_graph_setup() {
  graph_name = "NULL";
  i_cur_node = 0;
  i_cur_edge = 0; i_cur_painting_edge=0; i_cur_sculpting_edge=0;
  i_cur_predecessor=-1;
  i_cur_subsequent=-1;
}

class Node {
  float x,y; // node center coordinates
  float x_nav, y_nav; // temporary coordinates for navigation
  float w,h; // node circle width and height, respectively
  float w_nav,h_nav; // temporary sizes for navigation
  String id; // node identifier
  String text; // node text
  // String[] node_tags; int node_tags_counter; // node tags and counter 
  String node_tag;
  String media_type; // image (PNG, JPG), video, audio
  PImage node_image;
  
  // CheckBox[] node_menu_tags; // ListBox menu_tag; // DropdownList menu_tag;
  
  ToolTip tooltip;
  boolean select1, select2, deleted;

  Node(float x_aux, float y_aux, float w_aux, float h_aux, String id_aux, String text_aux, String tag_name_aux) {
    x=x_aux; y=y_aux; w=w_aux; h=h_aux; id=id_aux; text=text_aux; select1=false; select2=false; deleted=false;
    // node_tags = new String[total_tags]; node_tags_counter = 0; 
    node_tag = "NULL TAG";
    // THREE LINES UNUSED
    // if (!tag_name_aux.equals("NULL TAG")) {
      // node_tags[node_tags_counter++]=tag_name_aux; update_tag_lists(tag_name_aux, "ADD");
    // }
    // Tooltip_box(String i, String tt, float xc, float yc, float xw, float yh)
    tooltip = new ToolTip(text, x, y-w, size_x/2, size_y/2, default_font_name, default_font_size, default_font_aspect_ratio);
    media_type="NULL";
  }

  // adds a tag to a node, possibly creating it 
  public void add_node_tag(String tag_name) { 
    String tag_name_aux = tag_name;
    if (tag_name_aux.equals("NULL")) {tag_name_aux = create_tag();}
    // if (searchStringIndex(tag_name_aux, node_tags, 0, node_tags_counter)==-1) {
    //  node_tags[node_tags_counter++]=tag_name_aux;
    //  update_tag_lists(tag_name_aux, "ADD");
    //}
    node_tag = tag_name_aux;
    update_tag_lists(tag_name_aux, "ADD");
  }

  public void delete_node_tag(String tag_name) {
    // int tag_index = searchStringIndex(tag_name, node_tags, 0, node_tags_counter);
    //if (tag_index!=-1) {
    //  node_tags = deleteStringByIndex(tag_index, node_tags);
    //  node_tags_counter--;
    // }
    if (tag_name.equals(node_tag)) {node_tag = "NULL TAG";
    } else {showMessageDialog(null, "Different tag selected!", "Alert", ERROR_MESSAGE);}
  }

  public void modify_tag_name(String old_name, String new_name) {
    // replaceString(String old_name, String new_name, String[]list, int left, int right)
    // replaceString(old_name, new_name, node_tags, 0, node_tags_counter);
    if (old_name.equals(node_tag)) {node_tag = new_name;
    } else {showMessageDialog(null, "Different tag selected!", "Alert", ERROR_MESSAGE);}    
  }

  //void modify_tags() {
  //  // print("modifying tags:"); for (int j=0; j<node_tags_counter; j++) {print(" " + node_tags[j]);} print("\n");
  //  print4check("current tags:", 0, node_tags_counter, node_tags);
  //  node_tags_counter = 0; int i=0; // initialize_tag_list(node_tags);
  //  // print ("\n tags_checkbox items: "); for (int j=0; j<tags_checkbox.getItems().size(); j++) {print(tags_checkbox.getItem(j).getName() + " ");} print("\n");
  //  // print4check("cur_node_tags_from_checkbox: ", 0, 10, cur_node_tags_from_checkbox);
  //  while (!cur_node_tags_from_checkbox[i].equals("NULL TAG") && i<cur_node_tags_from_checkbox.length) {
  //    // println("modify_tags: " + cur_node_tags_from_checkbox[i]); 
  //    node_tags[node_tags_counter] = cur_node_tags_from_checkbox[i];
  //    node_tags_counter++; i++;
  //  }
  //  // hide_all_menus(); // tags_checkbox.hide();
  //  // initialize_tag_list(cur_node_tags_from_checkbox); // reset the temporary list of tags
  //  // println("modified tags:"); for (int j=0; j<node_tags_counter; j++) {print(" " + node_tags[j]);}
  //}

  // OBSOLETE: BASED ON MENUS
  //void show_tags() { 
  //  // println("showing tags:"); for (int j=0; j<node_tags_counter; j++) {print(" " + node_tags[j]);}
  //  int number_of_items = tags_checkbox.getItems().size();
  //  for (int j=0; j<number_of_items; j++) {tags_checkbox.getItem(j).setState(false);} // all items initialized to false
  //  for (int i=0; i<node_tags_counter; i++) { // for each tag of this node
  //    for (int j=0; j<number_of_items; j++) { // for each item of tag checkbox
  //      if (tags_checkbox.getItem(j).getName().equals(node_tags[i])) { // if the two names coincide
  //        tags_checkbox.getItem(j).setState(true);} // set item state to true 
  //    }
  //  }      
  //  tags_checkbox.setPosition((x+w/2)*zoom+xo,y*zoom+yo).show();
  //}

  public void show_tag() { // display the tag over the unit
    float bx = x; float by = y; // center coordinates of tag box rectangle initially set to unit center
    // String tag_box_text = "TAG "+node_tags[0];
    String tag_box_text = "TAG "+node_tag;
    String[] words = split_text_into_words (tag_box_text);
    float[] box_size = determine_box_size(words, default_font_aspect_ratio, default_font_size);
    float tag_box_width = box_size[0]; // id_general_length*default_font_width; 
    float tag_box_height = box_size[1]; // 2*default_font_size; // 2 lines TAG \n tag_id
    bx = check_horizontal_boundaries(x+w/2+tag_box_width/2, tag_box_width); // display at the right
    by = check_vertical_boundaries(y+tag_box_height/2, tag_box_height); // same y
    fill(0, 0, 100); //tbackground); WHITE background
    noStroke(); rectMode(CENTER);  
    rect(bx, by, tag_box_width, tag_box_height); 
    // fill(text_color); // BLACK text
    write_lines_in_fixed_fontsize(tag_box_text, default_font_name, default_font_aspect_ratio, default_font_size, "LEFT", "TOP", bx, by);
  } // END METHOD show_tag


  public void modify_text() {
    // public static String showInputDialog(Object message)
    // public static String showInputDialog(Object message, Object initialSelectionValue)
    // public static String showInputDialog(Component parentComponent, Object message)
    // public static String showInputDialog(Component parentComponent, Object message, Object initialSelectionValue)
    // public static String showInputDialog(Component parentComponent, Object message, String title,int messageType) 
    // public static Object showInputDialog(...) // throws HeadlessException
                     // Component parentComponent, --- - the parent Component for the dialog
                     // Object message, --- the Object to display
                     // String title, --- the String to display in the dialog title bar
                     // int messageType, --- the type of message to be displayed: ERROR_MESSAGE, INFORMATION_MESSAGE, WARNING_MESSAGE, QUESTION_MESSAGE, or PLAIN_MESSAGE
                     // Icon icon, --- the Icon image to display
                     // Object[] selectionValues, --- an array of Objects that gives the possible selections
                     // Object initialSelectionValue) ---  the value used to initialize the input field
    JTextArea textArea = new JTextArea(text);
    JScrollPane scrollPane = new JScrollPane(textArea);  
    textArea.setLineWrap(true);  
    textArea.setWrapStyleWord(true); 
    scrollPane.setPreferredSize(new Dimension(300, 200));
    String text_aux = showInputDialog(null, scrollPane, "Modify and paste into lower pane", PLAIN_MESSAGE);
    // Object aux = showInputDialog(null, scrollPane, "Modify the text", PLAIN_MESSAGE, null, null, scrollPane);
    // String text_aux = (String) aux;
    //String text_aux = showInputDialog("Please enter new text", scrollPane);
    // if (text_aux == null) exit(); else
    // public static void showMessageDialog(Component parentComponent, Object message)
    // public static void showMessageDialog(Component parentComponent, Object message, String title, int messageType)
    // public static void showMessageDialog(...) throws HeadlessException
      // Component parentComponent, --- Frame in which the dialog is displayed; if null, or if the parentComponent has no Frame, a default Frame is used
      // Object message, --- the Object to display
      // String title, --- the title string for the dialog
      // int messageType, --- type of message to be displayed: ERROR_MESSAGE, INFORMATION_MESSAGE, WARNING_MESSAGE, QUESTION_MESSAGE, or PLAIN_MESSAGE
      // Icon icon) --- icon to display in the dialog that helps the user identify the kind of message that is being displayed
    if (text_aux == null || "".equals(text_aux))
      showMessageDialog(null, "Empty TEXT Input!", "Alert", WARNING_MESSAGE);
    else if (search_node_text(text_aux)!=-1)
      showMessageDialog(null, "TEXT \"" + text_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);
    else {
      JTextArea textArea_2 = new JTextArea(text_aux);
      JScrollPane scrollPane_2 = new JScrollPane(textArea_2);  
      textArea_2.setLineWrap(true);  
      textArea_2.setWrapStyleWord(true); 
      scrollPane_2.setPreferredSize(new Dimension(300, 200));
      showMessageDialog(null, scrollPane_2, "Successfully modified", INFORMATION_MESSAGE);
      // showMessageDialog(null, "TEXT \"" + text_aux + "\" successfully modified!", "Successfully modified", INFORMATION_MESSAGE);
      text=text_aux;
      tooltip.text=text;
    }
  }

  public void modify_id() {
    String cur_id = id;
    String id_aux = showInputDialog("Please enter new ID", cur_id);
    // if (text_aux == null) exit(); else
    if (id_aux == null || "".equals(id_aux))
      showMessageDialog(null, "Empty ID Input!!!", "Alert", ERROR_MESSAGE);
    else if (search_node_text(id_aux)!=-1)
      showMessageDialog(null, "ID \"" + id_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);
    else {
      showMessageDialog(null, "ID \"" + id_aux + "\" successfully added!!!", "Info", INFORMATION_MESSAGE);
      id=id_aux;
      if (text.equals("NULL")) {tooltip.text=id; text=id;}
      for (int j=0; j<i_cur_edge; j++) {
        Edge e = (Edge) edges[j];
        if (e.tail_id.equals(cur_id)) {e.tail_id = id;} 
        if (e.head_id.equals(cur_id)) {e.head_id = id;}
      }
    }
  }

  public void delete() {
    println("deleting node " + id);
    deleted = true; 
    // deleted_nodes[num_deleted++]=i;
    for (int j=0; j<i_cur_edge; j++) {
      Edge e = (Edge) edges[j];
      if (e.tail_id==id || e.head_id==id) {e.delete();}
    }
  }

  public void create_node() {
  }

  // node DRAWING in NAV
  public void draw_node_in_nav(String cur_pre_sub) {
    // println("Draw node " + id); // PRINT CHECK: //<>//<>//
    if (cur_pre_sub.equals("cur")) { // draw the current node
      // *** draw node and text
      fill(compute_node_color());
      stroke(edge_color); ellipseMode(CENTER); strokeWeight(1);
      ellipse((left_offset+actual_width/2)/zoom-xo, (top_offset+actual_height/2)/zoom-yo, 
              actual_width/3, actual_width/3);
      fill(text_color);
      flex_write_lines_in_box(text, default_font_name, default_font_aspect_ratio, "CENTER", "CENTER", 
                              x_nav, y_nav, w_nav, h_nav);
      display_image();
    } else // predecessor nodes
    if (cur_pre_sub.equals("pre")) { // draw a predecessor
      // *** draw node and text
      fill(compute_node_color());
      stroke(edge_color); ellipseMode(CENTER); strokeWeight(1);
      ellipse(x_nav, y_nav, diameter_size, diameter_size);
      fill(text_color);
      flex_write_lines_in_box(id, default_font_name, default_font_aspect_ratio, "CENTER", "CENTER", 
                              x_nav, y_nav, w_nav, h_nav);      
    } else // the other nodes
    if (cur_pre_sub.equals("sub")) { // draw a subsequent
      // *** draw node and text
      fill(compute_node_color());
      stroke(edge_color); ellipseMode(CENTER); strokeWeight(1);
      ellipse(x_nav, y_nav, diameter_size, diameter_size);
      fill(text_color);
      flex_write_lines_in_box(id, default_font_name, default_font_aspect_ratio, "CENTER", "CENTER", 
                              x_nav, y_nav, w_nav, h_nav);      
    }
  } // END draw_node

  public void compute_pred_subs() { //<>//<>//
    i_cur_predecessor=0; i_cur_subsequent=0;
    for (int i=0; i<i_cur_edge; i++) {
      Edge e = edges[i];
      if (!e.deleted) {
        if (e.head_id.equals(id)) {
          predecessor_node_ids[i_cur_predecessor++]=e.tail_id;
        } else 
        if (e.tail_id.equals(id)) {
          subsequent_node_ids[i_cur_subsequent++]=e.head_id;
        }  
      }
    }
  }
  
  public void modify_image(String image_file_path) {
    node_image = loadImage(image_file_path);
    media_type="image";
  }
    
  public void display_image() {
    if (media_type.equals("image") && display_b) {
      if (modality.equals("EDT")) {
        // println("QUI");
        imageMode(CENTER); image(node_image, x, y, (node_image.width*diameter_size)/node_image.height, diameter_size); 
      } else
      if (modality.equals("NAV")) {
        imageMode(CENTER); image(node_image, x_nav, y_nav); //, sg_logo.width*2*y_credits/sg_logo.height, 2*y_credits);
      }
    }
  }

  public int compute_node_color() {
    int return_color = color(0);
    if (select1) {return_color = select_color;} // 1st selected color
    else {
      // if (node_tags_counter>0) {
        // Tag t = searchTag(node_tags[0]);
        Tag t = searchTag(node_tag);
        if (t!=null) {return_color = t.tag_color; } // tag-based color 
        else {return_color = node_color;} // generic node color
      // } else {return_color = node_color;} // generic node color 
    }
    return return_color;
  }
  
  // node DRAWING in EDT
  public void draw_node() {
    // println("--- Draw node " + id); // PRINT CHECK:
    if (!deleted) { 
      // *** possibly draw selection border (if it is the case)
      fill(compute_node_color());
      // *** draw node and text
      stroke(edge_color); ellipseMode(CENTER); strokeWeight(1);
      ellipse(x, y, w, h);
      if (select1 || select2) {fill(select_text_color);} else {fill(text_color);}
      flex_write_lines_in_box(id, default_font_name, default_font_aspect_ratio, "CENTER", "CENTER", x, y, diameter_size, diameter_size);
      display_image();
    } // END not deleted
  } // END draw_node
}

public int searchNodeIdIndex(String id) {
  // println(id);
  for (int i=0; i<i_cur_node; i++) {
    if (nodes[i].id.equals(id) && !nodes[i].deleted) {return i;}
  }
  return -1;
}

public int search_node_text(String t) {
  // println(t);
  for (int i=0; i<i_cur_node; i++) {
    if (nodes[i].text.equals(t) && !nodes[i].deleted) {return i;}
  }
  return -1;
}
// LIBRARY FOR PROPP FUNCTIONS
// based on Lakoff elaboration of Propp functions
String[] propp_tooltips = {"Int(erdiction)", "Vio(lation)", "Cv: Complication villany", "L(eave)", "D(onor)", 
                     "hEro reacts", "F: gain magic", "G: uses maGic", "H: figHts villain", "I: defeats vIllain", 
                     "K: misfortune liquidated", "Rew(ard)"};
String[] proppTags = {"Interdiction", "Violation", "Complication", "Leave", "Donor", 
                      "Hero reacts", "Gain magic", "Uses magic", "Fights villain", "Defeats villain", 
                      "Misfortune liquidated", "Reward"};
int max_length_propp_tag = 21; // Misfortune liquidated
int max_length_propp_id = 3; // CoV
// String[] proppIds = {"Int", "Vio", "Cv", "L", "D", "E", "F", "G", "H", "I", "K", "Rew"}; // Lakoff style
String[] proppIds = {"Int", "Vio", "CoV", "Lea", "Don", "HRe", "GaM", "Use", "FiV", "DeV", "MiL", "Rew"};
int cur_unit_propp_tag_index = -1;
float[] propp_layout_x = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
float[] propp_layout_width = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
int[] propp_layout_colors = {color(0), color(0), color(0), color(0), color(0), color(0), color(0), color(0), color(0), color(0), color(0), color(0)};

Propp_function[] propp_functions;
int i_select_pf;

// color of propp function fields (hue 45o, increase saturation 10-90, B 100)
public void propp_color_setup() {
  colorMode(HSB, 360, 100, 100);
  float hue = 45; float mid_saturation = 50; float min_saturation = 10; float max_saturation = 90;
  // float saturation_interval = (max_saturation - min_saturation)/propp_tooltips.length;
  for (int i=0; i<propp_tooltips.length; i++) {
    // float saturation = min_saturation + saturation_interval * i;
    float saturation = mid_saturation;
    propp_layout_colors[i]=color(hue,saturation,100);
  }
}

public void propp_setup() {
  // propp_function_position_setup();
  propp_functions = new Propp_function[proppTags.length];
  propp_color_setup();
  i_select_pf = -1;
  for (int i=0; i<propp_tooltips.length; i++) {
    propp_layout_width[i] = (actual_width/propp_tooltips.length) - 2*margin;
    propp_layout_x[i] = left_offset+i*(margin+propp_layout_width[i]+margin)+margin+propp_layout_width[i]/2;
    propp_functions[i] = new Propp_function(i);
  //  if (i%2==0) {propp_layout_colors[i] = bg_color_1;} else  {propp_layout_colors[i] = bg_color_2;}
  }  
}

public void propp_layout_bg_matrix() {
  noStroke();
  for (int i=0; i<propp_tooltips.length; i++) {
    fill(propp_layout_colors[i]);
    rect(propp_layout_x[i]/zoom-xo, (top_offset+actual_height/2)/zoom-yo,
         propp_layout_width[i], actual_height);
           // actual_width/propp_tooltips.length, actual_height);
    // fill(text_color); textFont(default_font_type); textAlign(CENTER,TOP);
    // text(propp_tooltips[i], propp_layout_x[i]/zoom-xo, (top_offset+default_font_size)/zoom-yo);
  }
}

//// calculation of the propp function button position in the bottom offset
//void propp_function_position_setup() {
//  for (int i=0; i<propp_functions.length; i++) {
//      propp_ids[i].w = state_width; states[i].h = bottom_offset;  // rectangle
//      states[i].x = (left_offset + i*(state_width + margin) + states[i].w/2)/zoom-xo; 
//      states[i].y = (size_y - states[i].h/2)/zoom-yo;
//      states[i].tooltip.x = states[i].x; states[i].tooltip.y = states[i].y;
//    }
//  }
//}

// identify mouse click for a propp function
public int propp_function_click() {
  int i_select_aux=-1;
  float x = mouseX; float y = mouseY; // capture mouse position
  for (int i=0; i<propp_functions.length; i++) { // for each propp function 
    if (x < (propp_functions[i].x+propp_functions[i].w/2)*zoom+xo && x > (propp_functions[i].x-propp_functions[i].w/2)*zoom+xo && // if the mouse is over the pf box
        y < (propp_functions[i].y+propp_functions[i].h/2)*zoom+yo && y > (propp_functions[i].y-propp_functions[i].h/2)*zoom+yo) {
        i_select_aux=i; 
    }
  } // END FOR
  return i_select_aux;
}

// mouse selection for a propp function
public void pf_selection() {
  int i_select_aux = propp_function_click(); // choose a propp function
  if (i_select_aux!=-1) { // if successful
    if (selection_possible) { // if nothing was selected before
      i_select_pf = i_select_aux; select_type = "PROPP";  propp_functions[i_select_pf].selected = true; selection_possible=false;
    } else 
    if (select_type.equals("PROPP")) { // if previous selection is a propp function
      if (i_select_pf==i_select_aux) { // if same propp function, deselect
        propp_functions[i_select_pf].selected = false; i_select_pf = -1; select_type = "NULL"; selection_possible=true;
      }
    } else
    if (select_type.equals("NODE")) { // if previous selection is a node, allow propp function selection
      i_select_pf = i_select_aux; select_type = "NODE+PROPP"; propp_functions[i_select_pf].selected = true; selection_possible=false;
    }
  } // END PROPP FUNCTION WAS SELECTED
}

// draw state buttons
public void draw_propp_functions() {
  // PRP header
  //fill(text_color);
  //flex_write_lines_in_box("PRPs", default_font_name, default_font_aspect_ratio, 
  //                        "CENTER", "CENTER", 
  //                        (left_offset/2)/zoom-xo, (size_y-(bottom_offset)/2)/zoom-yo, left_offset, bottom_offset);  
  for (int i=0; i < propp_functions.length; i++) {
    if ((select_type=="PROPP" || select_type=="NODE+PROPP") && i==i_select_pf) {fill(select_color);} 
    else {fill(propp_functions[i].pf_color);} 
    rectMode(CENTER);
    rect(propp_functions[i].x,propp_functions[i].y,propp_functions[i].w,propp_functions[i].h);
    if ((select_type=="PROPP" || select_type=="NODE+PROPP") && i==i_select_pf) {fill(select_text_color);} 
    else {fill(text_color);}
    flex_write_lines_in_box(propp_functions[i].id, default_font_name, default_font_aspect_ratio, 
                            "CENTER", "CENTER", 
                            propp_functions[i].x, propp_functions[i].y, propp_functions[i].w, propp_functions[i].h);
  }
}



// propp function name layover through tooltip
public void pf_layover() {
  // search for the tooltip to display
  float x = mouseX; float y = mouseY; // capture mouse position
  for (int i=0; i<propp_functions.length; i++) { // for each propp function 
    ToolTip tt = propp_functions[i].tooltip; 
    if (x < (propp_functions[i].x+propp_functions[i].w/2)*zoom+xo && x > (propp_functions[i].x-propp_functions[i].w/2)*zoom+xo) { // if the mouse is over such state box
      if (y < (propp_functions[i].y+propp_functions[i].h/2)*zoom+yo && y > (propp_functions[i].y-propp_functions[i].h/2)*zoom+yo) {
        tt.x= x/zoom-xo; tt.y= y/zoom-yo; 
        int c = color(0, 0, 80, 10); 
        tt.setBackground(c); 
        tt.display();
      }
    }
  } // END FOR
} 


// PROPP FUNCTION CLASS DEFINITION
class Propp_function {
  String name;
  int propp_index;
  String id;
  float x,y;
  float w,h;
  float x_min, x_max, y_min, y_max;
  int pf_color;
  boolean selected;
  ToolTip tooltip;
  
  Propp_function (int index) {
    propp_index = index; name = proppTags[index]; id = proppIds[index]; 
    x=propp_layout_x[index]/zoom-xo; y=(size_y-bottom_offset/2)/zoom-yo; w=propp_layout_width[index]; h=bottom_offset; 
    pf_color = propp_layout_colors[index]; selected = false;
    tooltip = new ToolTip(propp_tooltips[index], x, y-w, size_x/2, size_y/2, default_font_name, default_font_size, default_font_aspect_ratio);
  }

} // END CLASS STATE
// =================================================================================================
// LOGIC CONSTRAINTS: based upon preconditions and effects 

// LIBRARY FOR STATES
State[] states;
String[] state_names;
String[] state_ids; int state_id_suffix = 0; // Tag id's are printed in the tag box
int total_states;
int max_states_per_node;
int i_cur_state;
int i_select_state;

public void states_settings() {
  total_states = 1000;
  max_states_per_node = total_states;
}

public void states_setup() {
  i_cur_state = 0;
  i_select_state = -1;
  states = new State[total_states];
  state_ids = new String[total_states];
  state_names = new String[total_states];
  // state_names[0] = "fake_state_0"; state_names[1] = "fake_state_1"; i_cur_state=2;
  // for each unit, calculate painting and sculting edges
  for (int i=0; i<i_cur_node; i++) {
    Unit u = (Unit) nodes[i];
    u.update_constraints_edges_preconditions();
    u.update_constraints_edges_effects();
  }
}

// color of state buttons (45, 30, 100)
public void states_color_setup() {
  colorMode(HSB, 360, 100, 100);
  if (i_cur_state>0) {
    // float color_interval = 45 / i_cur_state; float start = 50; //random(360);
    for (int i=0; i < i_cur_state; i++) {
      states[i].state_color = color(45, 30, 100);
    }
  }
}

// calculation of the state button position in the bottom offset
public void states_position_setup() {
  if (i_cur_state>0) {
    float state_width = actual_width / i_cur_state; // computes box height
    if (state_width >= left_offset) {state_width=left_offset;} // not more than diameter_size
    for (int i=0; i < i_cur_state; i++) {
      states[i].w = state_width; states[i].h = bottom_offset;  // rectangle
      states[i].x = (left_offset + i*(state_width + margin) + states[i].w/2)/zoom-xo; 
      states[i].y = (size_y - states[i].h/2)/zoom-yo;
      states[i].tooltip.x = states[i].x; states[i].tooltip.y = states[i].y;
    }
  }
}

public void update_states(String state_name, String mode) {
  // println("update_states: " + state_name + ", of " + i_cur_state + " states");
  switch (mode) {
    case("ADD"):
      if (searchStateIndex(state_name)==-1) {
        // println("i_cur_preconditions_checkbox: " + i_cur_preconditions_checkbox);
        state_names[i_cur_state] = state_name;
        states[i_cur_state] = new State(state_name);
        //preconditions_checkbox.addItem("PRE:" + states[i_cur_state].id, i_cur_preconditions_checkbox); 
        //preconditions_checkbox.getItem(i_cur_preconditions_checkbox).getCaptionLabel().alignX(RIGHT)._myPaddingX=preconditions_checkbox.getItem(i_cur_preconditions_checkbox).getWidth();
        //i_cur_preconditions_checkbox++;
        //effects_checkbox.addItem("EFF:" + states[i_cur_state].id, i_cur_effects_checkbox); i_cur_effects_checkbox++;
        i_cur_state++;
      }
      break;
    case("DEL"): // removing a state button and state labeling of a node (it should remove from checkbox)
      int index = searchStateIndex(state_name); // store the index of the state to delete
      if (index!=-1) { // if not null
        // REMOVING FROM CHECKBOX DOES NOT WORK!
        //preconditions_checkbox.removeItem("PRE:" + states[index].id);
        //effects_checkbox.removeItem("EFF:" + states[index].id);
        // delete the state from all the units that have it in preconditions or effects 
        for (int j=0; j<i_cur_node; j++) { // FOR EACH UNIT
          Unit u = (Unit) nodes[j];
          u.delete_unit_precondition("PRE:"+states[index].id);
          // print4check("After: Unit " + u.id + "(" + u.unit_preconditions_counter + " states)", 0, u.unit_preconditions_counter, u.unit_preconditions);
          u.delete_unit_effect("EFF:"+states[index].id);
          // print4check("After: Unit " + u.id + "(" + u.unit_effects_counter + " states)", 0, u.unit_effects_counter, u.unit_effects);
        } // END FOR EACH UNIT
        // delete state and copy back all the 
        states[index].delete();
        // auxiliary state list and auxiliary state id list (with one less)
        State[] states_aux = new State[i_cur_state-1]; String[] state_ids_aux = new String[i_cur_state-1];
        for (int i=0; i<index; i++) {states_aux[i]=states[i]; state_ids_aux[i]=state_ids[i];}
        for (int i=index; i<i_cur_state-1; i++) {states_aux[i]=states[i+1]; state_ids_aux[i]=state_ids[i+1];}
        for (int i=0; i<states_aux.length; i++) {states[i]=states_aux[i]; state_ids[i]=state_ids_aux[i];}
        i_cur_state--;
      }
      break;
  } // END SWITCH
  states_color_setup(); 
  states_position_setup();
  // println("update_states: " + i_cur_state + " states");
}

// identify mouse click for a state
public int state_click() {
  int i_select_aux=-1;
  float x = mouseX; float y = mouseY; // capture mouse position
  for (int i=0; i<i_cur_state; i++) { // for each state 
    if (x < (states[i].x+states[i].w/2)*zoom+xo && x > (states[i].x-states[i].w/2)*zoom+xo && // if the mouse is over the state box
        y < (states[i].y+states[i].h/2)*zoom+yo && y > (states[i].y-states[i].h/2)*zoom+yo) {
        i_select_aux=i; 
    }
  } // END FOR
  return i_select_aux;
}

// mouse selection for a state
public void state_selection() {
  int i_select_aux = state_click(); // choose a state
  if (i_select_aux!=-1) { // if successful
    if (selection_possible) { // if nothing was selected before
      i_select_state = i_select_aux; select_type = "STATE";  selection_possible=false;
    } else 
    if (select_type.equals("STATE")) { // if previous selection is a state
      if (i_select_state==i_select_aux) { // if same state, deselect
        i_select_state = -1; select_type = "NULL";  selection_possible=true;
      }
    } else
    if (select_type.equals("NODE")) { // if previous selection is a node, allow state selection
      i_select_state = i_select_aux; select_type = "NODE+STATE";  selection_possible=false;
    }
  } // END STATE WAS SELECTED
}

// draw state buttons
public void draw_states() {
  // STATEs header
  //fill(text_color);
  //flex_write_lines_in_box("STATEs", default_font_name, default_font_aspect_ratio, 
  //                        "CENTER", "CENTER", 
  //                        (left_offset/2)/zoom-xo, (size_y-(bottom_offset)/2)/zoom-yo, left_offset, bottom_offset);  
  for (int i=0; i < i_cur_state; i++) {
    // println("color of state " + i);
    if ((select_type=="STATE" || select_type=="NODE+STATE") && i==i_select_state) {fill(select_color);} 
    else {fill(states[i].state_color);} 
    if (!states[i].deleted) {
      rectMode(CENTER);
      rect(states[i].x,states[i].y,states[i].w,states[i].h);
      if ((select_type=="STATE" || select_type=="NODE+STATE") && i==i_select_state) {fill(select_text_color);} 
      else {fill(text_color);}
      flex_write_lines_in_box(states[i].id, default_font_name, default_font_aspect_ratio, 
                              "CENTER", "CENTER", 
                              states[i].x, states[i].y, states[i].w, states[i].h);
    }
  }
}

// search functions on states
public State searchState(String state_name) {
  for (int i=0; i<i_cur_state; i++) {
    if (states[i].name.equals(state_name)) {return states[i];} 
  }
  return null;
}

public State searchStateById(String state_id) {
  for (int i=0; i<i_cur_state; i++) {
    if (states[i].id.equals(state_id)) {return states[i];} 
  }
  return null;
}

public int searchStateIndex(String state_name) {
  for (int i=0; i<i_cur_state; i++) {
    if (states[i].name.equals(state_name)) {return i;} 
  }
  return -1;
}

public void initialize_state_list(String[] state_list) {
  for (int i=0; i<state_list.length; i++) {
    state_list[i]="NULL STATE";
  }
}

public String create_state() {
  String state_aux = showInputDialog("Please enter new state");
  if (state_aux == null || "".equals(state_aux))
    showMessageDialog(null, "Empty state!!!", "Alert", ERROR_MESSAGE);
  else if (searchStateIndex(state_aux)!=-1)
    showMessageDialog(null, "ID \"" + state_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);
  else {
    showMessageDialog(null, "ID \"" + state_aux + "\" successfully added!!!", "Info", INFORMATION_MESSAGE);
    //update_states(state_aux, "ADD");
  }
  return state_aux;
}
  
// create new identifier for state label on button
public String create_state_id(String new_name) { // creates id's (3 letters) for states
  boolean id_ok = false; String id_aux = "NULL"; 
  String suffix = str(state_id_suffix); if (suffix.length()==1) {suffix = "0"+suffix;}
  int index1=0, index2=1, index3=2;
  while (!id_ok) {
    // proposal
    if (new_name.length()>=3) {id_aux = str(new_name.charAt(index1)) + str(new_name.charAt(index2)) + str(new_name.charAt(index3++));}
    else if (new_name.length()>=2) {id_aux = str(new_name.charAt(index1)) + str(new_name.charAt(index2++)) + str(0);}
    else if (new_name.length()>=1) {id_aux = str(new_name.charAt(index1)) + str(0) + str(0);}
    // disposal
    if (searchStringIndex(id_aux, state_ids, 0, i_cur_state)==-1) {
      id_ok=true;
    }
  }
  println("NEW STATE ID = " + id_aux);
  return id_aux;
}  

// state name layover through tooltip
public void state_layover() {
  // search for the tooltip to display
  float x = mouseX; float y = mouseY; // capture mouse position
  for (int i=0; i<i_cur_state; i++) { // for each state 
    ToolTip tt = states[i].tooltip; 
    if (x < (states[i].x+states[i].w/2)*zoom+xo && x > (states[i].x-states[i].w/2)*zoom+xo) { // if the mouse is over such state box
      if (y < (states[i].y+states[i].h/2)*zoom+yo && y > (states[i].y-states[i].h/2)*zoom+yo) {
        // tt.x= x/zoom-xo; tt.y= y/zoom-yo; 
        tt.x= x/zoom-xo; tt.y= y/zoom-yo; 
        int c = color(0, 0, 80, 10); // color(0, 80, 255, 30);
        tt.setBackground(c); // color(0,80,255,30));
        tt.display();
      }
    }
  } // END FOR
} 


// STATE CLASS DEFINITION

class State {
  String name;
  String id;
  float x,y;
  float w,h;
  float x_min, x_max, y_min, y_max;
  int state_color;
  boolean deleted;
  ToolTip tooltip;
  
  State (String _name) {
    name = _name; x=-1; y=-1; w=left_offset; h=diameter_size; deleted = false;
    tooltip = new ToolTip(name, x, y-w, size_x/2, size_y/2, default_font_name, default_font_size, default_font_aspect_ratio);
    id = create_state_id(name); state_ids[i_cur_state]=id;
  }

  public void delete() {
    // println("deleting state " + name);
    deleted = true; 
  }

  public void modify_name() {
    State aux_a;
    String name_aux = showInputDialog("Please enter new state", name);
    if (name_aux == null || "".equals(name_aux))
      showMessageDialog(null, "Empty TEXT Input!!!", "Alert", ERROR_MESSAGE);
    else {
      aux_a = searchState(name_aux);
      if (aux_a!=null)
        {showMessageDialog(null, "STATE \"" + name_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);}
      else {
      showMessageDialog(null, "STATE \"" + name + "\" changed name into " + name_aux, "Info", INFORMATION_MESSAGE);
      for (int i=0; i<i_cur_node; i++) { // update state name in all units containing it
        Unit u = (Unit) nodes[i];
        u.replace_unit_precondition_name(name,name_aux);
        u.replace_unit_effect_name(name,name_aux);
      }
      replaceString(name, name_aux, state_names, 0, i_cur_state);
      name=name_aux; tooltip.text=name;
      int i = searchStringIndex(id, state_ids, 0, i_cur_state);
      // preconditions_checkbox.addItem(name, i);
      // effects_checkbox.addItem(name, i);
      // state_ids = deleteStringByIndex(i, state_ids); i_cur_state--; 
      String old_id = id;
      id = create_state_id(name); 
      replaceString(old_id, id, state_ids, 0, i_cur_state);
      // state_ids = insertStringAtIndex(id, i, state_ids); i_cur_state++;
      }
    }
  }  

} // END CLASS STATE

// LIBRARY PRE-EFFs

public void constraints_layout_bg() {
  color(HSB, 360,100,100);
  fill(0,0,95); // fill(45,30,100);
  rect((left_offset+actual_width/2)/zoom-xo, (top_offset+actual_height/2)/zoom-yo, actual_width, actual_height);
  // image(tension_bg, (left_offset+actual_width/2)/zoom-xo, (top_offset+actual_height/2)/zoom-yo, actual_width, actual_height);
}
// ******** ****************************** ************ 
// ******** **** EXPORT GENERIC GRAPH **** ************ 
// ******** ****************************** ************ 

File cur_selection = null;

public void write_storygraph(File selection) { // responds to command 'w'; File is a Java class
  if (selection == null) {
    println("Window was closed or the user hit cancel.");
    showMessageDialog(null, "Empty selection!!!", "Alert", ERROR_MESSAGE);
  } else {
    cur_selection = selection;
    println("User selected " + selection.getAbsolutePath());
    JSONObject json_graph; json_graph = new JSONObject();
    // save graph name
    json_graph.setString("name", graph_name);
    // save nodes
    JSONArray json_nodes; json_nodes = new JSONArray(); int node_counter=0;
    for (int i=0; i<i_cur_node; i++) {
      Unit u = (Unit) nodes[i];
      if (!nodes[i].deleted) {
        JSONObject json_node = new JSONObject();
        json_node.setString("id", u.id);
        json_node.setString("text", u.text);
        json_node.setString("unit tension", u.unit_tension_name);
        json_node.setString("unit tag", u.node_tag);
        json_node.setFloat("x", u.x);
        json_node.setFloat("y", u.y);
        json_node.setFloat("w", u.w);
        json_node.setFloat("h", u.h);
        // TAGS: save unit tags: first tag is the characterizing tag for positioning 
        // JSONArray json_unit_tags; json_unit_tags = new JSONArray();
        // for (int j=0; j<u.node_tags_counter; j++) {
          // JSONObject json_tag = new JSONObject(); json_tag.setString(str(j), u.node_tags[j]);
          // json_unit_tags.setJSONObject(j,json_tag);
        // }
        // json_node.setJSONArray("unit tags", json_unit_tags);
        // MEDIA: save node image 
        if (u.media_type.equals("image")) {
          json_node.setString("media_type", "image");
          u.node_image.save(u.id+"_img.png");
          json_node.setString("node_image", u.id+"_img.png");
        } else {json_node.setString("media_type", "null");}
        // PROPP TAG
        json_node.setFloat("unit propp tag index", u.unit_propp_tag_index);
        // PRE-EFFs: preconditions and effects
        JSONArray json_unit_preconditions; json_unit_preconditions = new JSONArray();
        for (int j=0; j<u.unit_preconditions_counter; j++) {
          JSONObject json_precondition = new JSONObject(); json_precondition.setString(str(j), u.unit_preconditions[j]);
          json_unit_preconditions.setJSONObject(j,json_precondition);
        }
        json_node.setJSONArray("unit preconditions", json_unit_preconditions);
        JSONArray json_unit_effects; json_unit_effects = new JSONArray();
        for (int j=0; j<u.unit_effects_counter; j++) {
          JSONObject json_effect = new JSONObject(); json_effect.setString(str(j), u.unit_effects[j]);
          json_unit_effects.setJSONObject(j,json_effect);
        }
        json_node.setJSONArray("unit effects", json_unit_effects);
        // TENSION
        // json_node.setInt("unit tension", u.unit_tension);
        // save unit agents
        JSONArray json_unit_agents; json_unit_agents = new JSONArray();
        for (int j=0; j<u.unit_agents_counter; j++) {
          JSONObject json_agent = new JSONObject(); json_agent.setString(str(j), u.unit_agents[j]);
          json_unit_agents.setJSONObject(j,json_agent);
        }
        json_node.setJSONArray("unit agents", json_unit_agents);
        
        json_nodes.setJSONObject(node_counter++, json_node);
      }
    }
    json_graph.setJSONArray("units", json_nodes);
    // save edges
    JSONArray json_edges; json_edges = new JSONArray(); int edge_counter=0;
    for (int i=0; i<i_cur_edge; i++) {
      if (!edges[i].deleted) {
        JSONObject json_edge = new JSONObject();
        //   Node head, tail; String id; // edge identifier String label;
        json_edge.setString("id", edges[i].id);
        json_edge.setString("label", edges[i].label);
        json_edge.setString("head", edges[i].head_id);
        json_edge.setString("tail", edges[i].tail_id);
        // save edge pg_modes
        JSONArray json_edge_pg_modes; json_edge_pg_modes = new JSONArray(); 
        for (int j=0; j<edges[i].pg_mode_counter; j++) {
          JSONObject json_edge_pg_mode = new JSONObject(); json_edge_pg_mode.setString(str(j), edges[i].pg_modes[j]); 
          json_edge_pg_modes.setJSONObject(j, json_edge_pg_mode);
        }
        json_edge.setJSONArray("pg modes", json_edge_pg_modes);
        
        json_edges.setJSONObject(edge_counter++, json_edge);
      }
    }
    json_graph.setJSONArray("edges", json_edges);
    // save agents
    JSONArray json_agents; json_agents = new JSONArray(); int agent_counter=0;
    for (int i=0; i<i_cur_agent; i++) {
      // if (!agents[i].deleted) {
        JSONObject json_agent = new JSONObject();
        //   Node head, tail; String id; // edge identifier String label;
        json_agent.setString("name", agents[i].name);

        json_agents.setJSONObject(agent_counter++, json_agent);
      //}
    }
    json_graph.setJSONArray("agents", json_agents);
    // save tags
    JSONArray json_tags; json_tags = new JSONArray(); int tag_counter=0;
    for (int i=0; i<i_cur_tag; i++) {
      JSONObject json_tag = new JSONObject();
      json_tag.setString("name", tags[i].name);
      json_tags.setJSONObject(tag_counter++, json_tag);
    }
    json_graph.setJSONArray("tags", json_tags);
    // save tensions
    JSONArray json_tensions; json_tensions = new JSONArray(); int tension_counter=0;
    for (int i=0; i<i_cur_tension; i++) {
      JSONObject json_tension = new JSONObject();
      json_tension.setString("name", tensions[i].name);
      json_tension.setInt("tension value", tensions[i].tension_value);
      json_tensions.setJSONObject(tension_counter++, json_tension);
    }
    json_graph.setJSONArray("tensions", json_tensions);
    // save states (preconditions and effects)
    JSONArray json_states; json_states = new JSONArray(); int state_counter=0;
    for (int i=0; i<i_cur_state; i++) {
      JSONObject json_state = new JSONObject();
      json_state.setString("name", state_names[i]);
      json_states.setJSONObject(state_counter++, json_state);
    }
    json_graph.setJSONArray("states", json_states);
    // write array in file
    saveJSONObject(json_graph, selection.getAbsolutePath());
  }
}


public void write_twine_graph(File selection) { // responds to Twine export button; File is a Java class
  if (selection == null) {
    println("Window was closed or the user hit cancel.");
    showMessageDialog(null, "Empty selection!!!", "Alert", ERROR_MESSAGE);
  } else {
    cur_selection = selection;
    println("User selected " + selection.getAbsolutePath());
    // preamble of the HTML file
    // String[] preamble = {"<!DOCTYPE html>","<html>","<head>","<meta charset=\"utf-8\">",
                      // "<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">","<title>",
                      // graph_name,
                      // "</title>","</head>","<body>"};
    String preamble = "<!DOCTYPE html>"+"\n<html>"+"\n<head>"+"\n<meta charset=\"utf-8\">"+
                      "\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">"+"\n<title>"+
                      graph_name+
                      "\n</title>"+"\n</head>"+"\n<body>";
    String postamble = "\n</body>"+"\n</html>";
    
    // XML structure of story graph  
    XML tw_storydata; tw_storydata = new XML("tw-storydata");
    tw_storydata.setString("name",graph_name);
    tw_storydata.setString("creator","Storygraphia");
    tw_storydata.setString("creator-version","0.9.5");
    tw_storydata.setString("format","Harlowe");
    tw_storydata.setString("format-version","3.3.3");
    tw_storydata.setString("tags","");
    tw_storydata.setString("zoom","1");
    
    XML[] tw_passagedatae; tw_passagedatae = new XML[i_cur_node]; 
    
    // for each unit 
    for (int i=0; i<i_cur_node; i++) {
      Unit u = (Unit) nodes[i];
      if (!nodes[i].deleted) {
        tw_passagedatae[i] = new XML("tw-passagedata");
        // create attributes-values from unit data
        tw_passagedatae[i].setString("pid",str(i));
        tw_passagedatae[i].setString("name",u.id);
        // tags
        String tags = u.node_tag;
        tw_passagedatae[i].setString("tags",tags);
        tw_passagedatae[i].setString("position",str(u.x+actual_width/2)+","+str(u.y+actual_height/2));
        float unit_side = (actual_width+actual_height)/i_cur_node;
        tw_passagedatae[i].setString("size",str(unit_side)+","+str(unit_side));
        // create content string c from text
        String content = "\n"+u.text;
        // for each edge
        for (int j=0; j<i_cur_edge; j++) {
          Edge e = (Edge) edges[j];
          if (!edges[j].deleted) {
          // if the edge has this unit as tail
            if (e.tail_id.equals(u.id)) {
              // accumulate content in the content string c 
              content = content + "\n" + "[[" + e.label + "|" + e.head_id + "]]";
            } // END if tail = u
        } // END if edge not deleted
      } // END for each edge
      // setContent c
      tw_passagedatae[i].setContent(content);
      // addChild to array tw_passagedatae
      tw_storydata.addChild(tw_passagedatae[i]);
      } // END if node not deleted
    } // END for each unit
    PrintWriter output;
    // Create a new file in the sketch directory
    output = createWriter(selection.getAbsolutePath()); 
    output.println(preamble);
    output.println(tw_storydata.toString());
    //saveXML(tw_storydata,selection.getAbsolutePath());
    output.println(postamble);
    output.flush();
    output.close();
  }
}


// ******** ****************************** ************ 
// ******** **** IMPORT GENERIC GRAPH **** ************ 
// ******** ****************************** ************ 

public void load_storygraph(File selection) { // File is a Java class
  if (selection == null) {
    println("Window was closed or the user hit cancel.");
    showMessageDialog(null, "Empty selection!!!", "Alert", ERROR_MESSAGE);
  } else {
    println("User selected " + selection.getAbsolutePath());
    cur_selection = selection;
    JSONObject json_graph;
    json_graph = loadJSONObject(selection.getAbsolutePath());
    // load name
    graph_name = json_graph.getString("name");
    // load nodes
    JSONArray json_nodes = json_graph.getJSONArray("units"); i_cur_node=json_nodes.size();
    for (int i=0; i<i_cur_node; i++) {
      JSONObject json_node = json_nodes.getJSONObject(i);
      //println("load_storygraph: node is " + json_node.getString("id"));
      // Node(float x_aux, float y_aux, String id_aux, String text_aux, String tag_aux)
      Unit u = new Unit(json_node.getFloat("x"), json_node.getFloat("y"), 
                          json_node.getFloat("w"), json_node.getFloat("h"), 
                          json_node.getString("id"), json_node.getString("text"), "NULL TAG");   
      // TAG
      u.node_tag = json_node.getString("unit tag");
      // MEDIA 
      if (json_node.getString("media_type")!=null) {
        u.media_type = json_node.getString("media_type");
        if (u.media_type.equals("image")) {u.node_image = loadImage(json_node.getString("node_image"));}
      }
      // PROPP TAG
      u.unit_propp_tag_index = json_node.getInt("unit propp tag index");
      // STATES (preconditions and effects)
      JSONArray json_unit_preconditions = json_node.getJSONArray("unit preconditions"); 
      int preconditions_number=json_unit_preconditions.size();
      if (preconditions_number > 0) {
        u.unit_preconditions_counter = preconditions_number; 
        for (int j=0; j<u.unit_preconditions_counter; j++) {
          JSONObject json_precondition = new JSONObject(); json_precondition = json_unit_preconditions.getJSONObject(j);
          u.unit_preconditions[j] = json_precondition.getString(str(j)); // println(u.unit_preconditions[j].substring(4)); // update_states(u.unit_preconditions[j].substring(4), "ADD");
        }  
      } else {u.unit_preconditions_counter = 0;}
      JSONArray json_unit_effects = json_node.getJSONArray("unit effects"); 
      int effects_number=json_unit_effects.size();
      if (effects_number > 0) {
        u.unit_effects_counter = effects_number; 
        for (int j=0; j<u.unit_effects_counter; j++) {
          JSONObject json_effect = new JSONObject(); json_effect = json_unit_effects.getJSONObject(j);
          u.unit_effects[j] = json_effect.getString(str(j)); // println(u.unit_effects[j].substring(4)); // update_states(u.unit_effects[j].substring(4), "ADD");
        }  
      } else {u.unit_effects_counter = 0;}
      // TENSION
      u.unit_tension_name = json_node.getString("unit tension");
      // AGENTS
      // println("load_storygraph: agents are " + u.unit_agents_counter);
      JSONArray json_unit_agents = json_node.getJSONArray("unit agents"); u.unit_agents_counter=json_unit_agents.size();
        // println("load_storygraph: agents are " + u.unit_agents_counter);
      for (int j=0; j<u.unit_agents_counter; j++) {
        JSONObject json_agent = new JSONObject(); json_agent = json_unit_agents.getJSONObject(j);
        u.unit_agents[j] = json_agent.getString(str(j));
        // println("load_storygraph: agent " + u.unit_agents[j]);
      }
      nodes[i]=u;
    }
    // load edges
    JSONArray json_edges = json_graph.getJSONArray("edges"); i_cur_edge=json_edges.size();
    for (int i=0; i<i_cur_edge; i++) {
      JSONObject json_edge = json_edges.getJSONObject(i);
      // Edge(Node head_aux, Node tail_aux, String id_aux, String label_aux, String pg_mode)
      int head_index = searchNodeIdIndex(json_edge.getString("head"));
      int tail_index = searchNodeIdIndex(json_edge.getString("tail"));
      edges[i] = new Edge(nodes[head_index].id, nodes[tail_index].id, json_edge.getString("id"), json_edge.getString("label"), "NULL");
      // println("new edge: " + edges[i].id);
      // load pg_modes
      // String[] pg_modes = new String [plot_generation_modes.length]; for (int j=0; j<pg_modes.length; j++) {pg_modes[j]="NULL";}
      JSONArray json_edge_pg_modes = json_edge.getJSONArray("pg modes"); int edge_pg_modes_number=json_edge_pg_modes.size();
      if (edge_pg_modes_number > 0) {
        edges[i].pg_mode_counter = edge_pg_modes_number;        
        for (int j=0; j<edges[i].pg_mode_counter; j++) {
          JSONObject json_edge_pg_mode = new JSONObject(); json_edge_pg_mode = json_edge_pg_modes.getJSONObject(j);
          edges[i].pg_modes[j] = json_edge_pg_mode.getString(str(j));
        }
        // edges[i].pg_modes = pg_modes;
      // } else {edges[i].pg_mode_counter = 0;}
      } else {showMessageDialog(null, "Empty creation mode for edges! \n Check input file! Program quits!", "Alert", WARNING_MESSAGE); exit();}
      if (edges[i].is_pg_mode_edge("MANUAL") || edges[i].is_pg_mode_edge("PROPP") || edges[i].is_pg_mode_edge("TENSION")) { 
        edges[i].add_mode("MANUAL"); edges[i].add_mode("TENSION"); edges[i].add_mode("PROPP");   
      }
    }
    // load agents
    JSONArray json_agents = json_graph.getJSONArray("agents"); 
    for (int i=0; i<json_agents.size(); i++) {
      JSONObject json_agent = json_agents.getJSONObject(i);
      update_agents(json_agent.getString("name"), "ADD");
    }
    // load tags
    JSONArray json_tags = json_graph.getJSONArray("tags"); 
    for (int i=0; i<json_tags.size(); i++) {
      JSONObject json_tag = json_tags.getJSONObject(i);
      update_tag_lists(json_tag.getString("name"), "ADD");
    }
    // load tensions
    JSONArray json_tensions = json_graph.getJSONArray("tensions"); 
    for (int i=0; i<json_tensions.size(); i++) {
      JSONObject json_tension = json_tensions.getJSONObject(i);
      // Tension (String _name)
      // tensions[i] = new Tension(name, tension_value);
      // println("new tension: " + tension[i].name);
      update_tension_lists(json_tension.getString("name"), json_tension.getInt("tension value"), "ADD");
    }
    // load states
    JSONArray json_states = json_graph.getJSONArray("states"); 
    for (int i=0; i<json_states.size(); i++) {
      JSONObject json_state = json_states.getJSONObject(i);
      update_states(json_state.getString("name"), "ADD");
    }
  }
}

// ******** ********************************************* ************ 
// ******** INIT STORYGRAPH FROM TEXT FILE (ONE LINE PER NODE) ********** 
// ******** ********************************************* ************ 
public void load_storytext(File selection) { // File is a Java class
  noLoop();
  if (selection == null) {
    println("Window was closed or the user hit cancel.");
    showMessageDialog(null, "Empty selection!!!", "Alert", ERROR_MESSAGE);
  } else {
    println("User selected " + selection.getAbsolutePath());
    String[] lines = loadStrings(selection);
    int number_of_units_per_line = PApplet.parseInt(actual_width/diameter_size);
    int number_of_lines = PApplet.parseInt(actual_height/(2*diameter_size));
    if (lines.length > number_of_units_per_line*number_of_lines) {
      showMessageDialog(null, "Excessive number of units to load:  \"" + lines.length, "Alert", ERROR_MESSAGE);
      initial_page_setup(); generic_graph_setup(); story_specific_setup(); modality = "INI";
    } else {
      String cur_tag = "NULL TAG"; int cur_line = 0; int cur_node_position_in_line = 0; 
      float x = (left_offset+diameter_size/2)/zoom-xo;  float y = (top_offset+diameter_size/2)/zoom-yo;
      for (int i = 0; i < lines.length; i++) {
        // println("lines["+str(i)+"]= " + lines[i]);
        if (!lines[i].equals("")) {
          if (lines[i].charAt(0)=='[') { // this is a tag line
            // add this to tags
            cur_tag = lines[i]; update_tag_lists(cur_tag, "ADD"); println(cur_tag + " is a TAG!");
          } else { // this is a node line
            // compute node position
             if (cur_node_position_in_line < number_of_units_per_line) {x = x+diameter_size;} 
             else {x = left_offset; y = y + diameter_size;}             
            // Node(float x_aux, float y_aux, String id_aux, String text_aux, String tag_aux)
            // nodes[i_cur_node++] = new Unit(random(left_offset+diameter_size/zoom-xo,((left_offset+actual_width)-diameter_size)/zoom-xo), 
                                           // random((top_offset+diameter_size)/zoom-yo,((top_offset+actual_height)-diameter_size)/zoom-yo), 
            nodes[i_cur_node++] = new Unit(x, 
                                           y, 
                                           diameter_size, diameter_size, 
                                           "N" + str(hour()) + str(minute()) + str(second()) + node_counter++, 
                                           lines[i], cur_tag);  
          }
        }
      }
      tags_areas_setup();
      // for (int i = 0; i < i_cur_tag; i++) {println(i + ", x_min =" + tags[i].x_min + ", x_max =" + tags[i].x_max + ", y_min =" + tags[i].y_min + ", y_max =" + tags[i].y_max);}
      for (int i = 0; i < i_cur_node; i++) {
        println(nodes[i].node_tag);
        if (!nodes[i].node_tag.equals("NULL TAG")) {Tag t = searchTag(nodes[i].node_tag);
          //println(t.name + ": " + t.x_min);
          nodes[i].x = random(t.x_min/zoom-xo, t.x_max/zoom-xo); nodes[i].y = random(t.y_min/zoom-yo, t.y_max/zoom-yo);
        }
      }
    }
    loop();
    for (int i = 0; i < i_cur_node; i++) {print(nodes[i] + ", ");} print("\n");
  }
}
// LIBRARY FOR TAGS

Tag[] tags;
String[] tag_ids; int tag_id_suffix = 0; // Tag id's are printed in the tag box
int total_tags;
int i_cur_tag;
int i_select_tag;

public void tags_settings() {
  total_tags = 1000;
}

public void tags_setup() {
  i_cur_tag = 0;
  i_select_tag = -1;
  tags = new Tag[total_tags];
  tag_ids = new String[total_tags];
}

// color of state buttons (30% saturation, splitting hues, except 40-50 degrees)
public void tags_color_setup() {
  colorMode(HSB, 360, 100, 100);
  if (i_cur_tag>0) {
    float color_interval = 350 / i_cur_tag; float start = 0; // 350 because 10-degree exclusion
    boolean after_system_interval = false;
    for (int i=0; i < i_cur_tag; i++) {
      float hue = start+color_interval*i;
      // tags[i].tag_color = color((start+color_interval*i)%360,30,100);
      if (hue > 40 && hue < 50 && !after_system_interval) {tags[i].tag_color = color(hue+10,30,100); after_system_interval=true;}
      else if (after_system_interval) {tags[i].tag_color = color(hue+10,30,100);}
      else tags[i].tag_color = color(hue,30,100);
    }
  }
}

// calculation of the tag button position in the right offset
public void tags_position_setup() {
  if (i_cur_tag>0) {
    float tag_height = actual_height / i_cur_tag; // computes box height
    if (tag_height >= diameter_size) {tag_height=diameter_size;} // not more than diameter_size
    for (int i=0; i < i_cur_tag; i++) {
      tags[i].h = tag_height; tags[i].w = right_offset; // rectangle
      tags[i].x = (width - tags[i].w/2)/zoom-xo; 
      tags[i].y = (2 * top_offset + (tag_height + margin)*(i + 0.5f))/zoom-yo;
      tags[i].tooltip.x = tags[i].x; tags[i].tooltip.y = tags[i].y;
    }
  }
}

// updates related to the creation/deletion of tags (tag list and checkbox)
public void update_tag_lists(String tag_name, String mode) {
  // println("update_tag_lists: " + tag_name + ", of " + i_cur_tag + " tags");
  // print ("\n tags_checkbox items: "); for (int i=0; i<tags_checkbox.getItems().size(); i++) {print(tags_checkbox.getItem(i).getName() + " ");} print("\n");
  switch (mode) {
    case("ADD"):
      if (searchTag(tag_name)==null) {
        tags[i_cur_tag] = new Tag(tag_name);
        // tags_checkbox.addItem(tag_name, i_cur_tag_checkbox++);
        i_cur_tag++;
      }
    break;
    case("DEL"): // removing a tag button and tag labeling of a node (it should remove from checkbox)
      Tag[] tags_aux = new Tag[i_cur_tag-1]; String[] tag_ids_aux = new String[i_cur_tag-1];
      int index = searchTagIndex(tag_name);
      if (index!=-1) {
        // REMOVING FROM CHECKBOX DOES NOT WORK!
        //println(tags_checkbox.getItems());
        //for (int i=0; i<tags_checkbox.getItems().size(); i++) {println(tags_checkbox.getItem(i).getName());} 
        // tags_checkbox.deactivate(tag_name);
        // tags_checkbox.removeItem(tag_name);
        // println(tags_checkbox.getItems());
        for (int i=0; i<index; i++) {tags_aux[i]=tags[i]; tag_ids_aux[i]=tag_ids[i];}
        for (int i=index; i<i_cur_tag-1; i++) {tags_aux[i]=tags[i+1]; tag_ids_aux[i]=tag_ids[i+1];}
        for (int i=0; i<tags_aux.length; i++) {tags[i]=tags_aux[i]; tag_ids[i]=tag_ids_aux[i];}
        i_cur_tag--;
      }
    break;
  } // END SWITCH
  tags_color_setup(); 
  tags_position_setup();
  // println("update_tag_lists: " + i_cur_tag + " tags");
}

// mouse click on a tag button
public int tag_click() {
  int i_select_aux=-1;
  float x = mouseX; float y = mouseY; // capture mouse position
  for (int i=0; i<i_cur_tag; i++) { // for each tag 
    if (x < (tags[i].x+tags[i].w/2)*zoom+xo && x > (tags[i].x-tags[i].w/2)*zoom+xo && // if the mouse is over the tag box
        y < (tags[i].y+tags[i].h/2)*zoom+yo && y > (tags[i].y-tags[i].h/2)*zoom+yo) {
        i_select_aux=i; 
    }
  } // END FOR
  return i_select_aux;
}

// selection of a tag button
public void tag_selection() {
  int i_select_aux = tag_click(); // choose a tag
  if (i_select_aux!=-1) { // if successful
    if (selection_possible) { // if nothing was selected before
      i_select_tag = i_select_aux; select_type = "TAG";  selection_possible=false;
    } else 
    if (select_type.equals("TAG")) { // if previous selection is a tag
      if (i_select_tag==i_select_aux) { // if same tag, deselect
        i_select_tag = -1; select_type = "NULL";  selection_possible=true;
      }
    } else
    if (select_type.equals("NODE")) { // if previous selection is a node, allow agent selection
      i_select_tag = i_select_aux; select_type = "NODE+TAG";  selection_possible=false;
    }
  } // END TAG WAS SELECTED
}


// draw tag buttons
public void draw_tags() {
  // Tags header
  if (!white_page) {
    fill(text_color);
    flex_write_lines_in_box("TAGs", default_font_name, default_font_aspect_ratio, 
                          "CENTER", "CENTER", 
                          (size_x-right_offset/2)/zoom-xo, (1.5f*top_offset)/zoom-yo, right_offset, top_offset);  
  }
  for (int i=0; i < i_cur_tag; i++) {
    // println("color of tag " + i);
    if ((select_type=="TAG"||select_type=="NODE+TAG") && i==i_select_tag) {fill(select_color);} 
    else {fill(tags[i].tag_color);} 
    if (!tags[i].deleted) {
      // if the tag is not deleted, draw its button, with name
      rectMode(CENTER);
      rect(tags[i].x,tags[i].y,tags[i].w,tags[i].h);
      if ((select_type=="TAG"||select_type=="NODE+TAG") && i==i_select_tag) {fill(select_text_color);} 
      else {fill(text_color);}
      flex_write_lines_in_box(tags[i].id, default_font_name, default_font_aspect_ratio, 
                              "CENTER", "CENTER", 
                              tags[i].x, tags[i].y, tags[i].w, tags[i].h);
    }
  }
}

// search functions on tags
public Tag searchTag(String tag_name) {
  for (int i=0; i<i_cur_tag; i++) {
    if (tags[i].name.equals(tag_name)) {return tags[i];} 
  }
  return null;
}

public int searchTagIndex(String tag_name) {
  for (int i=0; i<i_cur_tag; i++) {
    if (tags[i].name.equals(tag_name)) {return i;} 
  }
  return -1;
}

public void initialize_tag_list(String[] tag_list) {
  for (int i=0; i<tag_list.length; i++) {
    tag_list[i]="NULL TAG";
  }
}

public String create_tag() {
  String tag_aux = showInputDialog("Please enter new tag");
  if (tag_aux == null || "".equals(tag_aux))
    showMessageDialog(null, "Empty tag!!!", "Alert", ERROR_MESSAGE);
  else if (searchTag(tag_aux)!=null)
    showMessageDialog(null, "ID \"" + tag_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);
  else {
    showMessageDialog(null, "ID \"" + tag_aux + "\" successfully added!!!", "Info", INFORMATION_MESSAGE);
    update_tag_lists(tag_aux, "ADD");
  }
  return tag_aux;
}
  
// PROBABLY USELESS --- SETUP USED, BUT x_min, ... NOT USED
public void tags_areas_setup() {
  if (i_cur_tag>0) {
    float tag_area_width = (size_x-left_offset) / i_cur_tag;
    if (tag_area_width <= diameter_size) {diameter_size = tag_area_width;} 
    for (int i=0; i < i_cur_tag; i++) {
      tags[i].x_min = left_offset + i*tag_area_width; tags[i].x_max = tags[i].x_min + tag_area_width;
      tags[i].y_min = top_offset; tags[i].y_max = size_y;
    }
  }
}

// create new identifier for tag label on button
public String create_tag_id(String new_name) { // creates id's (3 letters) for tags
  boolean id_ok = false; String id_aux = "NULL"; 
  String suffix = str(tag_id_suffix); if (suffix.length()==1) {suffix = "0"+suffix;}
  int index1=0, index2=1, index3=2;
  while (!id_ok) {
    // proposal
    if (new_name.length()>=3) {id_aux = str(new_name.charAt(index1)) + str(new_name.charAt(index2)) + str(new_name.charAt(index3++));}
    else if (new_name.length()>=2) {id_aux = str(new_name.charAt(index1)) + str(new_name.charAt(index2++)) + str(0);}
    else if (new_name.length()>=1) {id_aux = str(new_name.charAt(index1)) + str(0) + str(0);}
    // disposal
    if (searchStringIndex(id_aux, tag_ids, 0, i_cur_tag)==-1) {
      id_ok=true;
    }
  }
  println("NEW TAG ID = " + id_aux);
  return id_aux;
}  

// tag name layover through tooltip
public void tag_layover() {
  // search for the tooltip to display
  float x = mouseX; float y = mouseY; // capture mouse position
  for (int i=0; i<i_cur_tag; i++) { // for each tag 
    ToolTip tt = tags[i].tooltip; 
    if (x < (tags[i].x+tags[i].w/2)*zoom+xo && x > (tags[i].x-tags[i].w/2)*zoom+xo) { // if the mouse is over such state box
      if (y < (tags[i].y+tags[i].h/2)*zoom+yo && y > (tags[i].y-tags[i].h/2)*zoom+yo) {
        tt.x= x/zoom-xo; tt.y= y/zoom-yo; 
        int c = color(0, 0, 80, 10); // color(0, 80, 255, 30);
        tt.setBackground(c); // color(0,80,255,30));
        tt.display();
      }
    }
  } // END FOR
} 

// TAG CLASS DEFINITION
class Tag {
  String name;
  String id;
  float x,y;
  float w,h;
  float x_min, x_max, y_min, y_max;
  int tag_color;
  boolean deleted;
  ToolTip tooltip;
  
  Tag (String _name) {
    name = _name; x=-1; y=-1; w=right_offset; h=diameter_size; deleted = false;
    tooltip = new ToolTip(name, x, y-w, size_x/2, size_y/2, default_font_name, default_font_size, default_font_aspect_ratio);
    id = create_tag_id(name); tag_ids[i_cur_tag]=id;
  }
 
  public void delete() {
    // println("deleting tag " + name);
    deleted = true; 
    // delete the tag from all the nodes that are tagged with it
    for (int j=0; j<i_cur_node; j++) {
      Node n = nodes[j];
      // print4check("Before: Unit " + u.id + "(" + u.unit_tags_counter + " agents)", 0, u.unit_tags_counter, u.unit_tags);
      if (n.node_tag.equals(name)) n.node_tag="NULL TAG";
      // int k=0; boolean found = false;
      //while (k<n.node_tags_counter && !found) {
      //  if (n.node_tags[k].equals(name)) {found = true;} else {k++;}
      //} // END FOR EACH UNIT TAG
      //if (found) { println("DELETE"); 
      //             n.node_tags = deleteStringByIndex(k, n.node_tags); 
      //             n.node_tags_counter--;
      //          }
      // print4check("After: Node " + n.id + "(" + n.node_tags_counter + " tags)", 0, n.node_tags_counter, n.node_tags);
    } // END FOR EACH NODE
    update_tag_lists(name,"DEL");
  }
  
  public void modify_name() {
    Tag aux_a;
    String name_aux = showInputDialog("Please enter new tag", name);
    if (name_aux == null || "".equals(name_aux))
      showMessageDialog(null, "Empty TEXT Input!!!", "Alert", ERROR_MESSAGE);
    else {
      aux_a = searchTag(name_aux);
      if (aux_a!=null)
        {showMessageDialog(null, "TAG \"" + name_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);}
      else {
      showMessageDialog(null, "TAG \"" + name + "\" changed name into " + name_aux, "Info", INFORMATION_MESSAGE);
      for (int i=0; i<i_cur_node; i++) { // update tag name in all nodes containing it
        nodes[i].modify_tag_name(name, name_aux);
      }
      name=name_aux; tooltip.text=name;
      // String old_id = id;
      int i = searchStringIndex(id, tag_ids, 0, i_cur_tag);
      // tags_checkbox.addItem(name, i);
      tag_ids = deleteStringByIndex(i, tag_ids); i_cur_tag--; // temporarily, tags are decreased
      id = create_tag_id(name); 
      tag_ids = insertStringAtIndex(id, i, tag_ids); i_cur_tag++;
      // replaceString(old_id, id, tag_ids, 0, i_cur_tag);
      }
    }
  }  
}
// =================================================================================================
// DRAMATIC TENSION (integer number between 1 and 100) 
int min_tension = 1; int max_tension = 100; 
PImage tension_bg;
int cur_unit_tension_index = -1;

public void tension_bg_setup() {
  tension_bg = loadImage("tension_90.png"); // loadImage("tension.png");
}

public float tension_position(int tension) {
  float y = -1; int tension_interval = max_tension-min_tension;
  float y_relative = (tension * actual_height) / tension_interval;
  y = top_offset + (actual_height - y_relative);
  return y;
}

public void tension_layout_update(String tension_name) {
  // println("tension_layout_update");
  for (int i=0; i<i_cur_node; i++) {
    Unit u = (Unit) nodes[i]; 
    if (u.unit_tension_name.equals(tension_name)) {
      Tension t = search_tension(u.unit_tension_name);
      u.y = tension_position(t.tension_value)/zoom-yo;
    }
  }
}

public void tension_layout_bg() {
  image(tension_bg, (left_offset+actual_width/2)/zoom-xo, (top_offset+actual_height/2)/zoom-yo, actual_width, actual_height);
}

// LIBRARY FOR TENSIONS

Tension[] tensions;
String[] tension_ids; int tension_id_suffix = 0; // tension id's are printed in the tension box
int total_tensions;
int i_cur_tension;
int i_select_tension;

public void tensions_settings() {
  total_tensions = 1000;
}

public void tensions_setup() {
  i_cur_tension = 0;
  i_select_tension = -1;
  tensions = new Tension[total_tensions];
  tension_ids = new String[total_tensions];
}

// color of a tension button (on inverse intensity +y +dark)  1 -> 90; 100 -> 50; 50 -> 70
public int tension_color_calculation(float y) {
  colorMode(HSB, 360, 100, 100);
  int c = color(0,0,0);
  float min_B = 50; float max_B = 90; // brightness: 50 max tension; 90 min tension 
  c = color(0,0,max_B-(y*(max_B-min_B))/100); // inverse proportional brightness
  return c;
}

// calculation of the tension button position along the bottom offset
public void tensions_position_setup() {
  if (i_cur_tension>0) {
    float tension_width = actual_width / i_cur_tension; // computes box width
    if (tension_width >= left_offset) {tension_width=left_offset;} // not more than left_offset
    for (int i=0; i < i_cur_tension; i++) {
      tensions[i].w = tension_width; 
      tensions[i].h = bottom_offset; // tension_height; 
      tensions[i].x = (left_offset + (tension_width + margin)*(i + 0.5f))/zoom-xo;
      tensions[i].y = (size_y - bottom_offset/2)/zoom-yo; 
      tensions[i].tooltip.x = tensions[i].x; tensions[i].tooltip.y = tensions[i].y;
    }
  }
}

public void update_tension_lists(String tension_name, int value, String mode) {
  // println("update_tension_lists: " + tension_name + ", of " + i_cur_tension + " tensions");
  // print ("\n tensions_checkbox items: "); for (int i=0; i<tensions_checkbox.getItems().size(); i++) {print(tensions_checkbox.getItem(i).getName() + " ");} print("\n");
  switch (mode) {
    case("ADD"):
      if (search_tension(tension_name)==null) {
        tensions[i_cur_tension] = new Tension(tension_name, value);
        // tensions_checkbox.addItem(tension_name, i_cur_tension_checkbox++);
        i_cur_tension++;
      }
    break;
    case("DEL"): // removing a tension button and tension labeling of a node (it should remove from checkbox)
      Tension[] tensions_aux = new Tension[i_cur_tension-1]; String[] tension_ids_aux = new String[i_cur_tension-1];
      int index = search_tension_index(tension_name);
      if (index!=-1) {
        // REMOVING FROM CHECKBOX DOES NOT WORK!
        //println(tensions_checkbox.getItems());
        //for (int i=0; i<tensions_checkbox.getItems().size(); i++) {println(tensions_checkbox.getItem(i).getName());} 
        // tensions_checkbox.deactivate(tension_name);
        // tensions_checkbox.removeItem(tension_name);
        // println(tensions_checkbox.getItems());
        for (int i=0; i<index; i++) {tensions_aux[i]=tensions[i]; tension_ids_aux[i]=tension_ids[i];}
        for (int i=index; i<i_cur_tension-1; i++) {tensions_aux[i]=tensions[i+1]; tension_ids_aux[i]=tension_ids[i+1];}
        for (int i=0; i<tensions_aux.length; i++) {tensions[i]=tensions_aux[i]; tension_ids[i]=tension_ids_aux[i];}
        i_cur_tension--;
      }
    break;
  } // END SWITCH
  tensions_position_setup();
  // println("update_tension_lists: " + i_cur_tension + " tensions");
}

// mouse click on a tension button
public int tension_click() {
  int i_select_aux=-1;
  float x = mouseX; float y = mouseY; // capture mouse position
  for (int i=0; i<i_cur_tension; i++) { // for each tension 
    if (x < (tensions[i].x+tensions[i].w/2)*zoom+xo && x > (tensions[i].x-tensions[i].w/2)*zoom+xo && // if the mouse is over the tension box
        y < (tensions[i].y+tensions[i].h/2)*zoom+yo && y > (tensions[i].y-tensions[i].h/2)*zoom+yo) {
        i_select_aux=i; 
    }
  } // END FOR
  return i_select_aux;
}

// selection of a tension button
public void tension_selection() {
  int i_select_aux = tension_click(); // choose a tension
  if (i_select_aux!=-1) { // if successful
    if (selection_possible) { // if nothing was selected before
      i_select_tension = i_select_aux; select_type = "TENSION";  selection_possible=false;
    } else 
    if (select_type.equals("TENSION")) { // if previous selection is a tension
      if (i_select_tension==i_select_aux) { // if same tension, deselect
        i_select_tension = -1; select_type = "NULL";  selection_possible=true;
      }
    } else
    if (select_type.equals("NODE")) { // if previous selection is a node, allow agent selection
      i_select_tension = i_select_aux; select_type = "NODE+TENSION";  selection_possible=false;
    }
  } // END tension WAS SELECTED
}


// draw tension buttons
public void draw_tensions() {
  // tensions header
  //fill(text_color);
  //flex_write_lines_in_box("TNSs", default_font_name, default_font_aspect_ratio, 
  //                        "CENTER", "CENTER", 
  //                        (left_offset/2)/zoom-xo, (size_y-(bottom_offset)/2)/zoom-yo, left_offset, bottom_offset);  
  // list of tensions
  for (int i=0; i < i_cur_tension; i++) {
    // if the tension is not deleted, draw its button, with name
    if (!tensions[i].deleted) {
      if ((select_type=="TENSION"||select_type=="NODE+TENSION") && i==i_select_tension) {fill(select_color);}
      else {fill(tensions[i].tension_color);} 
      rectMode(CENTER);
      rect(tensions[i].x,tensions[i].y,tensions[i].w,tensions[i].h);
      if ((select_type=="TENSION"||select_type=="NODE+TENSION") && i==i_select_tension) {fill(select_text_color);} 
      else {fill(text_color);}
      flex_write_lines_in_box(tensions[i].id, default_font_name, default_font_aspect_ratio, 
                              "CENTER", "CENTER", 
                              tensions[i].x, tensions[i].y, tensions[i].w, tensions[i].h);
      // draw a dashed line with the tension value
      strokeWeight(1); stroke(0,0,80);
      // line(left_offset/zoom-xo, tension_position(tensions[i].tension_value)/zoom-yo, (left_offset+actual_width)/zoom-xo, tension_position(tensions[i].tension_value)/zoom-yo);
      dash.line(left_offset/zoom-xo, tension_position(tensions[i].tension_value)/zoom-yo, (left_offset+actual_width)/zoom-xo, tension_position(tensions[i].tension_value)/zoom-yo);
      textAlign(LEFT,BOTTOM); fill(0,0,30); textSize(default_font_size);
      text(str(tensions[i].tension_value), left_offset/zoom-xo, tension_position(tensions[i].tension_value)/zoom-yo);
    }
  }
}

// search functions on tensions
public Tension search_tension(String tension_name) {
  for (int i=0; i<i_cur_tension; i++) {
    if (tensions[i].name.equals(tension_name)) {return tensions[i];} 
  }
  return null;
}

public int search_tension_index(String tension_name) {
  for (int i=0; i<i_cur_tension; i++) {
    if (tensions[i].name.equals(tension_name)) {return i;} 
  }
  return -1;
}

//void initialize_tension_list(String[] tension_list) {
//  for (int i=0; i<tension_list.length; i++) {
//    tension_list[i]="NULL tension";
//  }
//}

public String create_tension() {
  String tension_aux = showInputDialog("Please enter new tension");
  if (tension_aux == null || "".equals(tension_aux))
    showMessageDialog(null, "Empty tension!!!", "Alert", ERROR_MESSAGE);
  else if (search_tension(tension_aux)!=null)
    showMessageDialog(null, "ID \"" + tension_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);
  else {
    showMessageDialog(null, "ID \"" + tension_aux + "\" successfully added!!!", "Info", INFORMATION_MESSAGE);
    // update_tension_lists(tension_aux, "ADD");
  }
  return tension_aux;
}
  
//// PROBABLY USELESS --- SETUP USED, BUT x_min, ... NOT USED
//void tensions_areas_setup() {
//  if (i_cur_tension>0) {
//    float tension_area_width = (size_x-left_offset) / i_cur_tension;
//    if (tension_area_width <= diameter_size) {diameter_size = tension_area_width;} 
//    for (int i=0; i < i_cur_tension; i++) {
//      tensions[i].x_min = left_offset + i*tension_area_width; tensions[i].x_max = tensions[i].x_min + tension_area_width;
//      tensions[i].y_min = top_offset; tensions[i].y_max = size_y;
//    }
//  }
//}

// create new identifier for tension label on button
public String create_tension_id(String new_name) { // creates id's (3 letters) for tensions
  boolean id_ok = false; String id_aux = "NULL"; 
  String suffix = str(tension_id_suffix); if (suffix.length()==1) {suffix = "0"+suffix;}
  int index1=0, index2=1, index3=2;
  while (!id_ok) {
    // proposal
    if (new_name.length()>=3) {id_aux = str(new_name.charAt(index1)) + str(new_name.charAt(index2)) + str(new_name.charAt(index3++));}
    else if (new_name.length()>=2) {id_aux = str(new_name.charAt(index1)) + str(new_name.charAt(index2++)) + str(0);}
    else if (new_name.length()>=1) {id_aux = str(new_name.charAt(index1)) + str(0) + str(0);}
    // disposal
    if (searchStringIndex(id_aux, tension_ids, 0, i_cur_tension)==-1) {
      id_ok=true;
    }
  }
  println("NEW tension ID = " + id_aux);
  return id_aux;
}  

// tension name layover through tooltip
public void tension_layover() {
  // search for the tooltip to display
  float x = mouseX; float y = mouseY; // capture mouse position
  for (int i=0; i<i_cur_tension; i++) { // for each tension 
    ToolTip tt = tensions[i].tooltip; 
    if (x < (tensions[i].x+tensions[i].w/2)*zoom+xo && x > (tensions[i].x-tensions[i].w/2)*zoom+xo) { // if the mouse is over such state box
      if (y < (tensions[i].y+tensions[i].h/2)*zoom+yo && y > (tensions[i].y-tensions[i].h/2)*zoom+yo) {
        tt.x= x/zoom-xo; tt.y= y/zoom-yo; 
        int c = color(0, 0, 80, 10); // color(0, 80, 255, 30);
        tt.setBackground(c); // color(0,80,255,30));
        tt.display();
      }
    }
  } // END FOR
} 

// tension CLASS DEFINITION
class Tension {
  String name;
  String id;
  float x,y;
  float w,h;
  float x_min, x_max, y_min, y_max;
  int tension_color;
  boolean deleted;
  int tension_value; // 1-100
  ToolTip tooltip;
  
  Tension (String _name, int _tension_value) {
    name = _name; x=-1; y=-1; w=right_offset; h=diameter_size; deleted = false;
    tension_value = _tension_value;
    tension_color = tension_color_calculation(tension_value); // medium value
    tooltip = new ToolTip(name+"-"+str(tension_value), x, y-w, size_x/2, size_y/2, default_font_name, default_font_size, default_font_aspect_ratio);
    id = create_tension_id(name); tension_ids[i_cur_tension]=id;
  }
 
  public void modify_tension_value() {    
    int n = PApplet.parseInt(showInputDialog("Please enter tension value [1-100]:", tension_value)); 
    if (n < 1 || n > 100) {
      showMessageDialog(null, "Invalid value!!!", "Alert", ERROR_MESSAGE);
    } else {
      if (tension_value!=n) {showMessageDialog(null, "Tension value \"" + n + "\" successfully modified!!!", "Info", INFORMATION_MESSAGE);}
      tension_value = n;  
      tension_color = tension_color_calculation(tension_value);
      tooltip.text=name+"-"+str(tension_value);
    }
  }

  public void delete() {
    // println("deleting tension " + name);
    deleted = true; 
    // delete the tension from all the units that are tensioned with it
    for (int j=0; j<i_cur_node; j++) {
      Unit u = (Unit) nodes[j];
      if (u.unit_tension_name.equals(name)) u.unit_tension_name = "NULL"; 
    } // END FOR EACH UNIT
    update_tension_lists(name, -1, "DEL");
  }
  
  public void modify_name() {
    Tension aux_t;
    String name_aux = showInputDialog("Please enter new tension description", name);
    if (name_aux == null || "".equals(name_aux))
      showMessageDialog(null, "Empty TEXT Input!!!", "Alert", ERROR_MESSAGE);
    else {
      aux_t = search_tension(name_aux);
      if (aux_t!=null)
        {showMessageDialog(null, "Tension \"" + name_aux + "\" exists already!!!", "Alert", ERROR_MESSAGE);}
      else {
      showMessageDialog(null, "Tension \"" + name + "\" changed name into " + name_aux, "Info", INFORMATION_MESSAGE);
      for (int i=0; i<i_cur_node; i++) { // update tension name in all nodes containing it
        Unit u = (Unit) nodes[i];
        if (u.unit_tension_name.equals(name)) u.modify_tension_name(name_aux);
      }
      name=name_aux; tooltip.text=name+str(tension_value);
      // String old_id = id;
      int i = searchStringIndex(id, tension_ids, 0, i_cur_tension);
      // tensions_checkbox.addItem(name, i);
      tension_ids = deleteStringByIndex(i, tension_ids); i_cur_tension--; // temporarily, tensions are decreased
      id = create_tension_id(name); 
      tension_ids = insertStringAtIndex(id, i, tension_ids); i_cur_tension++;
      // replaceString(old_id, id, tension_ids, 0, i_cur_tension);
      }
    }
  }  
}
// ##########################################################
// LIBRARY FOR TEXT LAYOUT 
// ##########################################################

// TEXT GLOBAL VARIABLES
float default_font_size = 12;
String default_font_name = "SansSerif"; // "CenturyGothic"; // "Monospaced"; 
float default_font_aspect_ratio = 0.6f; // 0.525;
float default_font_width = default_font_size*default_font_aspect_ratio; 
PFont default_font_type;
int text_color;
int id_general_length = 3;

public void text_setup() {
  default_font_type = createFont(default_font_name, default_font_size); textFont(default_font_type); 
}


// split a string into lines of certain length, returning an array of strings
public String[] split_string_into_lines (String s, float line_size) {
  // println("\ns = " + s + " and line size = " + line_size); 
  // extract all the original lines, according to RETURNs
  String[] words = split_text_into_words (s);  // for (int k=0; k < words.length; k++) {if (words[k].length() > line_size) {String[] s_={" "}; return s_;}}
  String original_lines[] = split(s, "\n");
  String actual_lines1[] = new String[s.length()]; // print("\n actual_lines1.length = " + actual_lines1.length);
  // count actual lines: for each line, split the string according to BLANKs or UNDERSCOREs, then split into words, count characters
  int line_count = 0; 
  for (int i = 0; i < original_lines.length; i++) {
    // words = split (original_lines[i], " "); 
    words = split_text_into_words(original_lines[i]); 
    int j = 0; 
    // print("\n number of words = " + words.length); for (int k = 0; k < words.length; k++) {print(" " + words[k]);} print("\n");
    while (j < words.length) { 
      int total_chars = 0; 
      String s_aux = "";
      while (j < words.length && total_chars + words[j].length()+1 < line_size) { // while there are words and do not exceed line size
        // println(j + " words[j] = " + words[j] + ", length " + words[j].length());
        total_chars = total_chars + words[j].length() + 1;  
        s_aux = s_aux + " " + words[j]; 
        j++; 
        s_aux = s_aux + " ";
      } // while char under single line size
      // print("\n line_count = " + line_count + " and j = " + j);
      if (s_aux.equals("")) {
        s_aux = " ..."; 
        j = words.length;
      }
      actual_lines1[line_count] = s_aux; 
      line_count++;
    } // END while all the words
  } // END for each line
  // fill actual lines to be returned
  String[] actual_lines = new String[line_count]; 
  for (int k = 0; k < line_count; k++) {
    actual_lines[k] = actual_lines1[k];
  } // END for each line
  return actual_lines;
}


// gives some text lines, computes the size of the box that contains it
public int[] box_size(String lines[], int font_size) {
  int[] total_w_h = {0, 0}; 
  int curWidth = 0; 
  for (int i=0; i<lines.length; i++) {
    total_w_h[1] = total_w_h[1] + font_size;
    curWidth = (int) textWidth(lines[i]);
    if (PApplet.parseInt(curWidth) > PApplet.parseInt(total_w_h[0])) {
      total_w_h[0] = curWidth;
    }
  }
  total_w_h[1] = total_w_h[1] + font_size;
  return total_w_h;
}

// split a string into words (" ", "_")
public String[] split_text_into_words (String text) {
  // println("split_text_into_words: " + text);
  String[] words = split (text, " "); 
  if (words.length<=1) {
    words = splitTokens (text, "_-,;:");
  }
  return words;
}

public int longest_word (String[] words) {
  int max=0;
  for (int i=0; i<words.length; i++) {
    if (max < words[i].length()) {
      max = words[i].length();
    }
  }
  return max;
}

// combine words into lines of certain length, returning an array of strings
public String[] combine_words_into_lines (String[] words, int line_size_in_characters) {
  // initialize a temporary array of lines that is as large as the number of words
  String[] actual_lines1 = new String[words.length+1]; 
  for (int i=0; i<words.length; i++) {actual_lines1[i]="";}
  // count actual lines: for each line, assemble words, count characters
  int line_count = 0;  
  for (int i = 0; i < words.length; i++) { // for each word    
    if (actual_lines1[line_count].length() + words[i].length() + 1 <= line_size_in_characters) { // while there are words and do not exceed line size
      actual_lines1[line_count] = actual_lines1[line_count] + words[i] + " "; 
    } else { 
      line_count = line_count+1; 
      actual_lines1[line_count] = words[i] + " "; // actual_lines1[line_count] + words[i] + " ";
    }
  } // END for each word
  // fill actual lines to be returned
  String[] actual_lines = new String[line_count+1]; 
  for (int k = 0; k < line_count+1; k++) {actual_lines[k] = actual_lines1[k];}
  
  return actual_lines;
}

// given some box, with x,y corner + width + height and some text and font size write the text in the box, if capable enough
public void flex_write_lines_in_box(String text, String font_type, float font_aspect_ratio, String x_align, String y_align, float x_center, float y_center, float x_width, float y_height) {
  // println(" = flex_write_lines_in_box = text: " + text + "; x_width: " + x_width);
  String[] words = split_text_into_words (text);
  //println(" = flex_write_lines_in_box = words[0]: " + words[0]);
  if (x_width >= y_height * 0.33f) { //  
    // println("#### flex_write_lines_in_box x_width = " + x_width + "; y_height = " + y_height + ": GO HORIZONTAL!!!");
    float font_size = determine_font_size (words, font_aspect_ratio, x_width, y_height);
    //println(" = flex_write_lines_in_box = font_size: " + font_size);
    int line_size = PApplet.parseInt (x_width / (font_size * font_aspect_ratio)); // in terms of characters 
    // println(" = flex_write_lines_in_box = line_size: " + line_size);
    String lines[] = combine_words_into_lines (words, line_size); 
    // println("number of lines = " + lines.length);
    float x = x_center; float y = y_center; 
    if (font_size>0) {
      PFont tfont = createFont(font_type, font_size); textFont(tfont);
      if (x_align.equals("LEFT") && y_align.equals("CENTER")) {
        textAlign(LEFT, CENTER); x = x_center - x_width/2; 
        if (lines.length%2!=0) {y = y_center-floor(lines.length*0.5f)*font_size;} else {y = y_center-(lines.length*0.5f*font_size);}
      } else if (x_align.equals("LEFT") && y_align.equals("TOP")) {
        textAlign(LEFT, TOP); x = x_center - x_width/2; y = y_center - y_height/2;
      } else if (x_align.equals("CENTER") && y_align.equals("CENTER")) {
        textAlign(CENTER, CENTER); x = x_center; 
        if (lines.length%2!=0) {y = y_center-floor(lines.length*0.5f)*font_size;} else {y = y_center-(lines.length*0.5f*font_size);}
      }
      for (int i=0; i<lines.length; i++) {
        float y_txt; if (lines.length%2!=0) {y_txt = y+i*font_size;} else {y_txt = y+(i+0.5f)*font_size;}
        // println("###### horizontal text: line = " + i + " of " + lines.length + ", " + lines[i] + "; x = " + x + ", y = " + y_txt);
        text(lines[i], x, y_txt); 
      }
    } else {
      PFont tfont = createFont(font_type, default_font_size); textFont(tfont);
      text("...", x, y);
    }
  } else { // VERTICAL
    // println("#### flex_write_lines_in_box x_width = " + x_width + "; y_height = " + y_height + ": GO VERTICAL!!!");
    // print the vertical text, in the center of the rectangle
    float font_size = determine_font_size (words, font_aspect_ratio, y_height, x_width);
    //println(" = flex_write_lines_in_box = font_size: " + font_size);
    int line_size = PApplet.parseInt (y_height / (font_size * font_aspect_ratio)); // in terms of characters 
    // println(" = flex_write_lines_in_box = line_size: " + line_size);
    String lines[] = combine_words_into_lines (words, line_size); 
    // println("number of lines = " + lines.length);
    float x = x_center; float y = y_center; 
    if (font_size > 0) {
      PFont tfont = createFont(font_type, font_size); textFont(tfont);
      if (x_align.equals("LEFT") && y_align.equals("CENTER")) {
        x = x_center - (lines.length*0.5f)*font_size; y = y_center + y_height/2.0f;
        // if (lines.length%2!=0) {y = y_center+y_height/2.0;} else {y = y_center+(lines.length*0.5*font_size);}
      } else if (x_align.equals("LEFT") && y_align.equals("TOP")) {
        x = x_center - x_width/2.0f; y = y_center + y_height/2.0f;
      } else if (x_align.equals("CENTER") && y_align.equals("CENTER")) {
        y = y_center; 
        if (lines.length%2!=0) {x = x_center-(lines.length*0.5f)*font_size;} else {x = x_center-(lines.length*0.5f*font_size);}
      }
      for (int i=0; i<lines.length; i++) {
        float x_txt; if (lines.length%2!=0) {x_txt = x+i*font_size;} else {x_txt = x+(i+0.5f)*font_size;}
        if (lines[i].equals("timeline ") || lines[i].equals("drama ")) {
        println("###### vertical_text: line = " + i + " of " + lines.length + ", " + lines[i] + "; x = " + x_txt + ", y = " + y);
        }
        if (x_align.equals("CENTER") && y_align.equals("CENTER")) {vertical_text(lines[i], x_txt, y, CENTER, CENTER);} else
        if (x_align.equals("LEFT") && y_align.equals("CENTER")) {vertical_text(lines[i], x_txt, y, LEFT, CENTER);} else
        if (x_align.equals("LEFT") && y_align.equals("TOP")) {vertical_text(lines[i], x_txt, y, LEFT, DOWN);} 
      }
    } else {
      PFont tfont = createFont(font_type, default_font_size); textFont(tfont);
      text("...", x, y);
    }
  }
}

// given some text and font size, write the text in the box
public void write_lines_in_fixed_fontsize(String text, String font_type, float font_aspect_ratio, float font_size, String x_align, String y_align, float x_center, float y_center) {
  // println(" = write_lines_in_fixed_fontsize = text: " + text + "; font_size: " + font_size);
  float x = x_center; float y = y_center; 
  String[] words = split_text_into_words (text);
  float[] box_size = determine_box_size(words, font_aspect_ratio, font_size);
  String lines[] = combine_words_into_lines (words, (int)(box_size[0]/(font_size*font_aspect_ratio))); 
  // println("number of lines = " + lines.length);
  if (x_align.equals("LEFT") && y_align.equals("CENTER")) {
    textAlign(LEFT, CENTER); 
    x = x_center - box_size[0]/2; 
    rectMode(CORNER);
  } else 
  if (x_align.equals("LEFT") && y_align.equals("TOP")) {
    textAlign(LEFT, TOP); 
    x = x_center - box_size[0]/2; 
    y = y_center - box_size[1]/2; 
    rectMode(CORNER);
  } else 
  if (x_align.equals("CENTER") && y_align.equals("CENTER")) {
    textAlign(CENTER, CENTER); 
    rectMode(CENTER);
  }  
  fill(0, 0, 100, 10); 
  noStroke(); // rectMode(CORNER);  
  rect(x, y, box_size[0], box_size[1]); 
  //println(" = write_lines_in_fixed_fontsize = box_size[0]: " + box_size[0] + "; box_size[1]: " + box_size[1]);
  fill(0); 
  if (font_size>0) {
    PFont tfont = createFont(font_type, font_size); 
    textFont(tfont);
    for (int i=0; i<lines.length; i++) {        
      text(lines[i], x, y+i*font_size);
      // text(lines[i],x_corner,y_corner);
    }
  } else {
    PFont tfont = createFont(font_type, default_font_size); 
    textFont(tfont);
    text("...", x, y);
  }
}

// given width, height, and font aspect ratio, this determines the font size for some text
public float determine_font_size (String[] words, float font_aspect_ratio, float x_width, float y_height) {
  int font_size = 1; // CLASS with font size 1
  int longest_word_length = longest_word(words); // compute the longest word length (minimum for line size)
  boolean max_size_found = false; // boolean for finding the possible max font size 
  while (!max_size_found) { // while not found the max font size
    int line_size = PApplet.parseInt (x_width / (font_size * font_aspect_ratio)); // compute the current line size in number of chars
    if (line_size > longest_word_length) { // if it is more than the longest word length
      String lines[] = combine_words_into_lines (words, line_size); // form the lines of the text 
      // println("font_size = " + font_size + "; line_size = " + line_size + "; lines[0] = " + lines[0]);
      if (lines.length * font_size <= y_height) {
        font_size=font_size+1;
      } else {
        max_size_found=true;
      }
    } else {
      max_size_found=true;
    }
  }
  if (font_size>1) {
    font_size = font_size - 1;
  } 
  //println("font_size = " + str(font_size-1));
  return font_size;
}

// given font size and aspect ratio, this determines the size of the box for some text
public float[] determine_box_size(String[] words, float font_aspect_ratio, float font_size) {
  float[] box_size = {0, 0}; // set to max size
  float box_aspect_ratio = 25/9;
  int line_size_in_chars = longest_word(words) + 1; // longest word length (minimum for line size) + blank after word
  float line_size = font_size * font_aspect_ratio * line_size_in_chars; // compute the current line size in number of pixels
  boolean box_size_found = false;
  while (!box_size_found) {
    line_size_in_chars = line_size_in_chars+1;
    line_size = font_size * font_aspect_ratio * line_size_in_chars;
    // if (line_size <= width/3) { // if it is more than the longest word length 
    String lines[] = combine_words_into_lines (words, line_size_in_chars); // form the lines of the text 
    //println("line_size = " + line_size + "; lines[0] = " + lines[0] + "; longest_word_length = " + longest_word_length);
    if (lines.length * font_size <= line_size/box_aspect_ratio) { 
      box_size[0] = line_size; 
      box_size[1] = line_size/box_aspect_ratio;
      box_size_found = true;
      //println("box_size[0] = " + box_size[0] + "; box_size[1] = " + box_size[1]);
    } 
    //}
  }
  for (int i=0; i<words.length;i++) {if (words[i].equals("\n")) {box_size[1]++;}}
  //println("font_size = " + str(font_size-1));
  return box_size;
}

// writing vertically
public void vertical_text(String phrase, float x, float y, int x_align, int y_align) {
  if (phrase.equals("timeline ") || phrase.equals("drama ")) {
  println("###### vertical_text inside: phrase = " + phrase + "; x = " + x + ", y = " + y);
  }
  pushMatrix();
  translate(x, y);
  rotate(-HALF_PI);
  textAlign(x_align, y_align);
  text(phrase, 0, 0);
  popMatrix();
}

// writing vertically
// void vertical_text_box(String phrase, PFont font, color c, float x, float y, float x_w, float y_h) {
public void vertical_text_box(String phrase, PFont font, float x, float y, float x_w, float y_h) {
  // fill(c);
  textAlign(CENTER, CENTER);
  // rectMode(CENTER);
  textFont(font);

  pushMatrix();
  translate(x, y+y_h);
  rotate(-HALF_PI);
  text(phrase, 0, 0, y_h, x_w);
  popMatrix();
}

// writing horizontally
public void horizontal_text_box(String phrase, PFont font, int c, float x, float y, float x_w, float y_h) {
  fill(c);
  textAlign(CENTER, CENTER);
  // rectMode(CENTER);
  textFont(font);

  pushMatrix();
  // translate(x, y+y_h);
  translate(x, y);
  text(phrase, 0, 0, x_w, y_h);
  popMatrix();
}
// ##########################################################
// Class to display a tooltip in a rectangle. 
// ##########################################################

class ToolTip{
  String text; // text of the tooltip
  float x,y; // x,y coordinate center
  float max_w, max_h;; // max width and height
  // aux variables
  int delta_x = 5; // horizontal space between mouse and tooltip 
  float tooltipWidth = 0; // width of the text
  float tooltipHeight = 0; // height of the text
  int tbackground = color(60, 60, 60, 10); //  // default background color  
  float font_size; float font_aspect_ratio; String font_name;
  
  // **** DEFINITION OF THE TOOLTIP OBJECT ****
  ToolTip(String _text, float _x, float _y, float _max_w, float _max_h, String _font_name, float _font_size, float _font_aspect_ratio){
    text = _text; x = _x; y = _y; max_w = _max_w; max_h = _max_h; font_name = _font_name; font_size = _font_size; font_aspect_ratio = _font_aspect_ratio; // set coordinates and text
    String[] words = split_text_into_words (text);
    float[] box_size = determine_box_size(words, font_aspect_ratio, font_size);
    if (box_size[0] <= max_w && box_size[1] <= max_h) {tooltipWidth = box_size[0]; tooltipHeight = box_size[1];}
    else {text = "NULL"; tooltipWidth = text.length()*font_aspect_ratio*font_size; tooltipHeight = font_size;}
  }
  
  public void setBackground(int c){
    tbackground = c;
  }
        
  public void display() { // display the tooltip (2017 july 3)
    float bx = x; float by = y; // center coordinates of tooltip box rectangle
    bx = check_horizontal_boundaries(x+tooltipWidth/2, tooltipWidth);
    by = check_vertical_boundaries(y-tooltipHeight/2, tooltipHeight);
    fill(0, 0, 100); //tbackground); 
    noStroke(); rectMode(CENTER); // rectMode(CORNER);  
    rect(bx, by, tooltipWidth, tooltipHeight); 
    write_lines_in_fixed_fontsize(text, font_name, font_aspect_ratio, font_size, "LEFT", "TOP", bx, by);
  } // END METHOD display

  public void displayStatic() { // display the tooltip  
    float bx = x; // int(x+delta_x);
    float by = y; // -tooltipHeight/2; // int(y-tooltipHeight);    
    fill(0xFF000000);
    flex_write_lines_in_box(text, font_name, font_aspect_ratio, "LEFT", "TOP", bx+margin, by, max_w-margin, max_h);     
    // }
  } // END METHOD display

} // END CLASS ToolTip


// text layover through tooltip, in editing mode
public void layover() {
  // search for the tooltips to display
  float tt_x = mouseX; float tt_y = mouseY; // capture mouse position
  for (int i=0; i<i_cur_node; i++) { // for each node that includes a tooltip 
    if (!nodes[i].deleted) {
      ToolTip tt = nodes[i].tooltip; 
      if (tt_x < (nodes[i].x+nodes[i].w/2)*zoom+xo && tt_x > (nodes[i].x-nodes[i].w/2)*zoom+xo) { // if the mouse is over such box
        if (tt_y < (nodes[i].y+nodes[i].h/2)*zoom+yo && tt_y > (nodes[i].y-nodes[i].h/2)*zoom+yo) {
          tt.x=tt_x/zoom-xo; tt.y=tt_y/zoom-yo; 
          tt.display();
        }
      }
    }
  } // END FOR nodes
  for (int i=0; i<i_cur_edge; i++) { // for each edge  
    if (!edges[i].deleted && searchStringIndex(plot_generation_mode, edges[i].pg_modes, 0, edges[i].pg_modes.length)!=-1) { // if not deleted
      ToolTip tt = edges[i].tooltip; // retrieve tooltip
      // retrieve head and tail nodes
      int head_index = searchNodeIdIndex(edges[i].head_id);  
      int tail_index = searchNodeIdIndex(edges[i].tail_id);
      Node head = nodes[head_index]; 
      Node tail = nodes[tail_index];
      // retrieve edge label coordinates
      float edgeLabel_x = (tail.x + head.x) / 2;
      float edgeLabel_y = (tail.y + head.y) / 2;
      if (tt_x < (edgeLabel_x+diameter_size/2)*zoom+xo && tt_x > (edgeLabel_x-diameter_size/2)*zoom+xo) { // if the mouse is over such box
        if (tt_y < (edgeLabel_y+diameter_size/2)*zoom+yo && tt_y > (edgeLabel_y-diameter_size/2)*zoom+yo) {
          tt.x=tt_x/zoom-xo; tt.y=tt_y/zoom-yo; 
          int c = color(0, 0, 80, 10); // color(0, 80, 255, 30);
          tt.setBackground(c); // color(0,80,255,30));
          tt.display(); // display the tooltip
        }
      }
    }
  } // END FOR each edge
  
}

// text layover through tooltip, in navigation mode
public void layover_nav() {
  // search for the tooltips to display
  float tt_x = mouseX; float tt_y = mouseY; // capture mouse position
  for (int i=0; i<i_cur_node; i++) { // for each node that includes a tooltip 
    if (!nodes[i].deleted && i!=cur_nav_node_index) {
      ToolTip tt = nodes[i].tooltip; 
      if (tt_x < (nodes[i].x_nav+nodes[i].w/2)*zoom+xo && tt_x > (nodes[i].x_nav-nodes[i].w_nav/2)*zoom+xo) { // if the mouse is over such box
        if (tt_y < (nodes[i].y_nav+nodes[i].h_nav/2)*zoom+yo && tt_y > (nodes[i].y_nav-nodes[i].h_nav/2)*zoom+yo) {
          tt.x=tt_x/zoom-xo; tt.y=tt_y/zoom-yo; 
          tt.display();
        }
      }
    }
  } // END FOR nodes
  for (int i=0; i<i_cur_edge; i++) { // for each edge that includes a tooltip 
    if (!edges[i].deleted) {
      ToolTip tt = edges[i].tooltip; 
      if (tt_x < (edges[i].label_x_nav+diameter_size/2)*zoom+xo && tt_x > (edges[i].label_x_nav-diameter_size/2)*zoom+xo) { // if the mouse is over such box
        if (tt_y < (edges[i].label_y_nav+diameter_size/2)*zoom+yo && tt_y > (edges[i].label_y_nav-diameter_size/2)*zoom+yo) {
          tt.x=tt_x/zoom-xo; tt.y=tt_y/zoom-yo; 
          int c = color(0, 0, 80, 10); // color(0, 80, 255, 30);
          tt.setBackground(c); // color(0,80,255,30));
          tt.display();
        }
      }
    }
  } // END FOR 
}
// STORY UNITS: GLOBAL VARIABLES
int max_agents_per_unit;

public void unit_settings() {
  max_agents_per_unit = 1000;
}


class Unit extends Node {
  String[] unit_agents; int unit_agents_counter;
  int unit_propp_tag_index; // one of {"Int", "Vio", "Cv", "L", "D", "E", "F", "G", "H", "I", "K", "Rew"}
  String[] unit_preconditions; int unit_preconditions_counter;
  String[] unit_effects; int unit_effects_counter;
  String unit_tension_name; // name of the tension
  
  Unit(float x_aux, float y_aux, float w_aux, float h_aux, String id_aux, String text_aux, String tag_aux) {
    // Node(float x_aux, float y_aux, float w_aux, float h_aux, String id_aux, String text_aux, String tag_aux)
    super(x_aux, y_aux, w_aux, h_aux, id_aux, text_aux, tag_aux);
    unit_agents = new String[max_agents_per_unit]; unit_agents_counter=0;
    unit_propp_tag_index = -1; unit_tension_name = "NULL"; unit_tension_name = "NULL";
    unit_preconditions = new String[total_states]; unit_preconditions_counter=0;
    unit_effects = new String[total_states]; unit_effects_counter=0;
    if (white_page) {white_page=false;}
  }

  //void show_states() {
  //  if (unique_event) {
  //    unique_event=false;
  //    println("showing preconditions:"); for (int j=0; j<unit_preconditions_counter; j++) {print(" " + unit_preconditions[j]);}
  //    int number_of_items = preconditions_checkbox.getItems().size();
  //    // println("number_of_items:" + number_of_items);
  //    // PRECONDITIONS
  //    for (int j=0; j<number_of_items; j++) {preconditions_checkbox.getItem(j).setState(false);} // all items initialized to false
  //    for (int i=0; i<unit_preconditions_counter; i++) { // for each precondition state of this node
  //      for (int j=0; j<number_of_items; j++) { // for each item of preconditions checkbox
  //        if (preconditions_checkbox.getItem(j).getName().substring(4).equals(unit_preconditions[i])) { // if the two names coincide (excluding "PRE:")
  //          preconditions_checkbox.getItem(j).setState(true);} // set item state to true 
  //      } // END for each precondition checkbox
  //    } // END for each precondition 
  //    preconditions_checkbox.setPosition((x-w/2-preconditions_checkbox.getWidth())*zoom+xo,y*zoom+yo).show();
  //    // EFFECTS
  //    for (int j=0; j<number_of_items; j++) {effects_checkbox.getItem(j).setState(false);} // all items initialized to false
  //    for (int i=0; i<unit_effects_counter; i++) { // for each effect state of this node
  //      for (int j=0; j<number_of_items; j++) { // for each item of effects checkbox
  //        if (effects_checkbox.getItem(j).getName().substring(4).equals(unit_effects[i])) { // if the two names coincide (excluding "EFF:")
  //          effects_checkbox.getItem(j).setState(true);} // set item state to true 
  //      } // END for each effect checkbox
  //    } // END for each effect
  //    effects_checkbox.setPosition((x+w/2)*zoom+xo,y*zoom+yo).show();
  //    unique_event=true;
  //  }
  //} // END SHOW STATES

  public void show_preconditions_and_effects() { // display the preconditions and the effects over the unit
    float bx = x; float by = y; // center coordinates of effects box rectangle initially set to unit center
    String effects_box_text = "EFFECTS: "; 
    if (unit_effects_counter==0) {effects_box_text = effects_box_text + "NULL";}
    else for (int i=0; i<unit_effects_counter; i++) {effects_box_text = effects_box_text + unit_effects[i] + " - ";}
    String[] words = split_text_into_words (effects_box_text);
    float[] box_size = determine_box_size(words, default_font_aspect_ratio, default_font_size);
    float effects_box_width = box_size[0]; 
    float effects_box_height = box_size[1]; 
    bx = check_horizontal_boundaries(x+w/2+effects_box_width/2, effects_box_width); // display at the right
    by = check_vertical_boundaries(y+effects_box_height/2, effects_box_height); //  display below
    String preconditions_box_text = "PRECONDITIONS: "; 
    if (unit_preconditions_counter==0) {preconditions_box_text = preconditions_box_text + "NULL";}
    else for (int i=0; i<unit_preconditions_counter; i++) {preconditions_box_text = preconditions_box_text + unit_preconditions[i] + " - ";}
    words = split_text_into_words (preconditions_box_text);
    box_size = determine_box_size(words, default_font_aspect_ratio, default_font_size);
    float preconditions_box_width = box_size[0];  
    float preconditions_box_height = box_size[1]; 
    float pre_bx = check_horizontal_boundaries(bx-effects_box_width/2-preconditions_box_width/2, preconditions_box_width); // display at the left of the effects
    float pre_by = check_vertical_boundaries(y+preconditions_box_height/2, preconditions_box_height); //  display below
    fill(0, 0, 100); //tbackground); WHITE background
    noStroke(); rectMode(CENTER);  
    rect(bx, by, effects_box_width, effects_box_height); 
    write_lines_in_fixed_fontsize(effects_box_text, default_font_name, default_font_aspect_ratio, default_font_size, "LEFT", "TOP", bx, by);
    fill(0, 0, 100); //tbackground); WHITE background
    noStroke(); rectMode(CENTER);  
    rect(pre_bx, pre_by, preconditions_box_width, preconditions_box_height); 
    write_lines_in_fixed_fontsize(preconditions_box_text, default_font_name, default_font_aspect_ratio, default_font_size, "LEFT", "TOP", pre_bx, pre_by);
  } // END METHOD show_proconditions_and_effects
  
  // add a precondition name to a unit
  public void add_unit_precondition(String state_name) {
    int i = searchStringIndex(state_name, state_names, 0, i_cur_state);
    int j = searchStringIndex(states[i].name, unit_preconditions, 0, unit_preconditions_counter);
    if (i!=-1 && j==-1) {
      unit_preconditions[unit_preconditions_counter]=states[i].name;
      unit_preconditions_counter++;
      update_constraints_edges_preconditions();
    }
  }

  // add an effect to a unit
  public void add_unit_effect(String state_name) {
    int i = searchStringIndex(state_name, state_names, 0, i_cur_state);
    int j = searchStringIndex(states[i].id, unit_effects, 0, unit_effects_counter);
    if (i!=-1 && j==-1) {
      unit_effects[unit_effects_counter]=states[i].name;
      unit_effects_counter++;
      update_constraints_edges_effects();
    }
  }

  // replace a precondition in a unit
  public void replace_unit_precondition_name(String old_name, String new_name) {
    for (int j=0; j<unit_preconditions_counter; j++)
      if (unit_preconditions[j].equals(old_name)) {
        unit_preconditions[j]=new_name; 
    }
  }

  // replace a effect in a unit
  public void replace_unit_effect_name(String old_name, String new_name) {
    for (int j=0; j<unit_effects_counter; j++)
      if (unit_effects[j].equals(old_name)) {
        unit_effects[j]=new_name; 
    }
  }

  // delete a precondition from a unit
  public void delete_unit_precondition(String state_name) {
    int index = -1;
    for (int i=0; i<unit_preconditions_counter; i++) {
      if (unit_preconditions[i].equals(state_name)) {index = i;}
    }
    if (index!=-1) {
      for (int i=0; i<index; i++) {unit_preconditions[i]=unit_preconditions[i];}    
      for (int i=index; i<unit_preconditions_counter; i++) {unit_preconditions[i]=unit_preconditions[i+1];} 
      unit_preconditions_counter--;
      update_constraints_edges_preconditions();
    }
  }

  // delete an effect from a unit
  public void delete_unit_effect(String state_name) {
    int index = -1;
    for (int i=0; i<unit_effects_counter; i++) {
      if (unit_effects[i].equals(state_name)) {index = i;}
    }
    if (index!=-1) {
      for (int i=0; i<index; i++) {unit_effects[i]=unit_effects[i];}    
      for (int i=index; i<unit_effects_counter; i++) {unit_effects[i]=unit_effects[i+1];} 
      unit_effects_counter--;
      update_constraints_edges_effects();
    }
  }

  //void modify_preconditions_from_checkbox() { 
  //  println("modifying preconditions: \n"); for (int i=0; i<unit_preconditions_counter; i++) {print(" " + unit_preconditions[i] + "\n");}
  //  unit_preconditions_counter = 0; // int i=0;
  //  for (int i=0; i<cur_unit_preconditions_from_checkbox.length; i++) {
  //  // while (!cur_unit_preconditions_from_checkbox[i].equals("NULL STATE") && i<cur_unit_preconditions_from_checkbox.length) {
  //    if (!cur_unit_preconditions_from_checkbox[i].equals("NULL STATE")) {
  //    // println("modify_preconditions_from_checkbox: unit_preconditions_from_checkbox " + i + "= " + cur_unit_preconditions_from_checkbox[i]); 
  //      unit_preconditions[unit_preconditions_counter] = cur_unit_preconditions_from_checkbox[i].substring(4);
  //      unit_preconditions_counter++; // i++;
  //    }
  //  }
  //  // hide_all_menus();
  //  update_constraints_edges_preconditions();
  //  // initialize_state_list(cur_unit_preconditions_from_checkbox); // reset the temporary list of preconditions
  //  // print("\n modified preconditions:"); for (int j=0; j<unit_preconditions_counter; j++) {print(" " + unit_preconditions[j]);}
  //}

  //void modify_effects_from_checkbox() { 
  //  println("modifying effects:"); for (int i=0; i<unit_effects_counter; i++) {print(" " + unit_effects[i]);}
  //  unit_effects_counter = 0; // int i=0;
  //  for (int i=0; i<cur_unit_effects_from_checkbox.length; i++) {
  //  // while (!cur_unit_effects_from_checkbox[i].equals("NULL STATE") && i<cur_unit_effects_from_checkbox.length) {
  //    if (!cur_unit_effects_from_checkbox[i].equals("NULL STATE")) {
  //    // println("modify_effects: unit_effects_from_checkbox " + i + "= " + cur_unit_effects_from_checkbox[i]); 
  //      unit_effects[unit_effects_counter] = cur_unit_effects_from_checkbox[i].substring(4);
  //      unit_effects_counter++; // i++;
  //    }
  //  }
  //  // hide_all_menus(); 
  //  update_constraints_edges_effects();
  //  // initialize_state_list(cur_unit_effects_from_checkbox); // reset the temporary list of effects
  //  // println("modified effects:"); for (int j=0; j<unit_effects_counter; j++) {print(" " + unit_effects[j]);}
  //}

  // *** NEXT TWO ARE UPDATES FOR PRECONDITIONS/EFFECTS CONSTRAINTS UNDER
  // *** *** MODALITY ADDITION (PAINTING): NO PRECONDITIONS -> NO UNIT CAN PRECEDE
  // *** *** MODALITY SUBTRACTION (SCULPTING): NO PRECONDITIONS -> ALL UNITS CAN PRECEDE
  public void update_constraints_edges_preconditions() { // update edges that get at this node (head)
    // println("update_constraints_edges_preconditions() for " + i_cur_node + " nodes and " + i_cur_edge + " edges");
    for (int i=0; i<i_cur_node; i++) { // for each other unit
      Unit ui = (Unit) nodes[i];  
      // *** TEST IF unit ui EFFECTS SATISFY ALL PRECONDITIONS of this unit
      int p=0; String state_name = "NULL"; boolean ui_satisfies = true; // ui satisfies this unit preconditions, when no precondition has been examined yet (p=0)
      while (p<unit_preconditions_counter && ui_satisfies) { // ; p++) { // for each precondition of this unit
        boolean found = false; // found one effect in ui that satisfies precondition number p
        for (int f=0; f<ui.unit_effects_counter; f++) { // find an effect in ui that satisfies this precondition
          if (ui.unit_effects[f].equals(unit_preconditions[p])) {
            found=true; State s = searchState(unit_preconditions[p]); state_name=s.name;
          } 
        }
        if (!found) {ui_satisfies=false;} // if not found, ui does not satisfy this unit preconditions
        p++;
      } // END WHILE - for each precondition of this unit
      if (plot_generation_mode.equals("PAINTING")) { // if PAINTING submode
        // *** ADD EDGE ... 
        if (unit_preconditions_counter>0 && ui_satisfies) { // if all preconditions (>0) are satisfied by ui effects
          if (search_edge_head_tail_index(searchNodeIdIndex(id), i, "PAINTING")==-1) { // if edge does not exist in PAINTING MODE
            int index = search_edge_head_tail_index(searchNodeIdIndex(id), i, "NULL");
            // *** ... BY CREATION OF A NEW EDGE (IN PAINTING MODE)
            if (index==-1) { // if edge does not exist at all, create edge
              create_edge(id, ui.id, state_name);
              // edges[i_cur_edge]=new Edge(id, ui.id, "e"+str(i_cur_edge), state_name, "PAINTING"); 
              // i_cur_edge++; 
            } else { // if edge exists, add PAINTING to pg_modes
            // *** ... BY ONLY ADDING PAINTING MODE TO EXISTING EDGE 
              int m=0; boolean added = false; 
              while (!added && m<edges[index].pg_modes.length) { // loop over edge modes to add PAINTING
                if (edges[index].pg_modes[m].equals("NULL")) {
                  edges[index].pg_modes[m]="PAINTING"; added=true; edges[index].pg_mode_counter++;} 
                else {m++;}           
              } // END WHILE edge modes
            } // END ELSE (edge exists)
          } // END IF (this edge does not exist in PAINTING mode)
        } else // *** NON SATISFACTION OR NO PRECONDITIONS: DELETE PAINTING MODE OR DELETE EDGE FROM UI           
        if ((!ui_satisfies || unit_preconditions_counter==0) && // if not all preconditions (>0) are satisfied by ui effects or 0 preconditions
             search_edge_head_tail_index(searchNodeIdIndex(id), i, "PAINTING")!=-1) { // and the edge exists
          int index = search_edge_head_tail_index(searchNodeIdIndex(id), i, "PAINTING");
          // DELETE PAINTING MODE FROM EDGE MODES
          replaceString("PAINTING", "NULL", edges[index].pg_modes, 0, edges[index].pg_modes.length); edges[index].pg_mode_counter--;
          // if pg_modes are all NULL, delete the edge
          if (allNullStrings(edges[index].pg_modes)) {
            edges[index].delete(); // delete the edge
          }
        } // END IF NO SATISFACTION OR 0 PRECONDITIONS
      } // else // END IF PAINTING MODE
      // ======================== SCULPTING MODE ========================
    //  if (plot_generation_mode.equals("SCULPTING")) { // if SCULPTING mode
    //    // *** ADD EDGE ... 
    //    if (unit_preconditions_counter==0 || ui_satisfies) { // if all preconditions are satisfied by ui effects, possibly because 0 preconditions
    //      if (search_edge_head_tail_index(searchNodeIdIndex(id), i, "SCULPTING")==-1) { // if edge does not exist in SCULPTING MODE
    //        int index = search_edge_head_tail_index(searchNodeIdIndex(id), i, "NULL");
    //        // *** ... CREATION OF A NEW EDGE (IN PAINTING MODE)
    //        if (index==-1) { // if edge does not exist at all, create edge
             // create_edge(id, ui.id, state_name);
    //          edges[i_cur_edge]=new Edge(id, ui.id, "e"+str(i_cur_edge), state_name, "PAINTING"); 
    //          i_cur_edge++; 
    //        } else { // if edge exists, add PAINTING to pg_modes
    //        // *** ... ADD PAINTING MODE TO EXISTING EDGE 
    //          int m=0; boolean added = false; 
    //          while (!added && m<edges[index].pg_modes.length) { // loop over edge modes to add PAINTING
    //            if (edges[index].pg_modes[m].equals("NULL")) {
    //              edges[index].pg_modes[m]="PAINTING"; added=true; edges[index].pg_mode_counter++;} 
    //            else {m++;}           
    //          }
    //        }
    //      }
    //    } else // *** NON SATISFACTION OR NO PRECONDITIONS: DELETE INCOMING EDGES FROM UI           
    //    if ((!ui_satisfies || unit_preconditions_counter==0) && // if not all preconditions (>0) are satisfied by ui effects or 0 preconditions
    //         search_edge_head_tail_index(searchNodeIdIndex(id), i, "PAINTING")!=-1) { // and the edge exists
    //      int index = search_edge_head_tail_index(searchNodeIdIndex(id), i, "PAINTING");
    //      replaceString("PAINTING", "NULL", edges[index].pg_modes, 0, edges[index].pg_modes.length); edges[index].pg_mode_counter--;
    //      // if pg_modes are all NULL, delete the edge
    //      if (allNullStrings(edges[index].pg_modes)) {
    //        edges[index].delete(); // delete the edge
    //      }
    //    } // END IF  
    //  } // END FOR EACH OTHER UNIT 
    //} // IF PAINTING MODE        
        
        //if (plot_generation_submode.equals("SCULPTING") && unit_preconditions_counter==0) {satisfied=true;}
        //else if (plot_generation_submode.equals("PAINTING") && unit_preconditions_counter==0) {satisfied=false;}
        //if (satisfied && search_edge_head_tail_index(searchNodeIdIndex(id), i)==-1) { // if all preconditions matched and edge does not exist, create edge
        //  // println("unit "+i+".unit_effects["+is+"] = " + ui.unit_effects[is]); println("unit "+j+".unit_preconditions["+js+"] = " + uj.unit_preconditions[js]); 
        //  create_edge(id, ui.id, "NULL");
        //  edges[i_cur_edge]=new Edge(id, ui.id, "e"+str(i_cur_edge), "NULL", plot_generation_mode); 
        //  i_cur_edge++;
        //} else 
        //if (!satisfied && search_edge_head_tail_index(searchNodeIdIndex(id), i)!=-1) {           
        //  edges[search_edge_head_tail_index(searchNodeIdIndex(id), i)].delete(); 
        //} 
      // } // END FOR EACH OTHER UNIT
    // } // END IF
    } // END FOR EACH UNIT
  }

  public void update_constraints_edges_effects() { // update edges that depart from this node (tail)
    // println("update_constraints_edges() for " + i_cur_node + " nodes and " + i_cur_edge + " edges");
    // if (plot_generation_mode == "PRE-EFFs") {
      if (plot_generation_mode.equals("PAINTING")) { // if PAINTING submode
        // add or delete painting edges to account for the current situation
        for (int i=0; i<i_cur_node; i++) { // for each other unit
          Unit ui = (Unit) nodes[i];  
          // *** if this unit satifies all the preconditions of ui, build a painting edge from u to ui (if not already existent)
          int p=0; boolean ui_satisfied = true; String state_name = "NULL"; // ui satisfied by this unit preconditions, when no precondition has been examined yet (p=0)
          while (p<ui.unit_preconditions_counter && ui_satisfied) { // for each precondition of unit ui
            boolean found = false; // found one effect in this unit that satisfies precondition number p (NOT YET = FALSE)
            for (int f=0; f<unit_effects_counter; f++) { // find an effect in this unit that satisfies current precondition of u
              if (unit_effects[f].equals(ui.unit_preconditions[p])) {
                found=true; State s = searchState(ui.unit_preconditions[p]); state_name=s.name;
              } 
            }
            if (!found) {ui_satisfied=false;} // if not found, this unit effects do not satisfy ui preconditions
            p++;
          } // END WHILE
          // *** ADD EDGE ... 
          if (ui.unit_preconditions_counter>0 && ui_satisfied) { // if all preconditions (>0) of ui are satisfied by this unit effects
            if (search_edge_head_tail_index(i, searchNodeIdIndex(id), "PAINTING")==-1) { // if edge does not exist in PAINTING MODE
              int index = search_edge_head_tail_index(searchNodeIdIndex(ui.id), i, "NULL");
              // *** ... BY CREATION 
              if (index==-1) { // if edge does not exist at all, create edge
                create_edge(ui.id, id, state_name);
                // edges[i_cur_edge]=new Edge(ui.id, id, "e"+str(i_cur_edge), state_name, "PAINTING"); 
                // i_cur_edge++;
              } else { // if edge exists, add PAINTING to pg_modes
              // *** ... BY ADDING MODE TO EXISTING EDGE
                int m=0; boolean added = false; 
                while (!added && m<edges[index].pg_modes.length) {
                  if (edges[index].pg_modes[m].equals("NULL")) {
                    edges[index].pg_modes[m]="PAINTING"; added=true; edges[index].pg_mode_counter++;} 
                  else {m++;}           
                }
              } // END ADD PAINTING TO MODES
            }
          } else 
          // *** NON SATISFACTION OR NO PRECONDITIONS: DELETE INCOMING EDGES FROM UI 
          if ((!ui_satisfied || ui.unit_preconditions_counter==0) && // if not all preconditions (>0) are satisfied by this unit effects or 0 preconditions
               search_edge_head_tail_index(i, searchNodeIdIndex(id), "PAINTING")!=-1) { // and the edge exists
            int index = search_edge_head_tail_index(i, searchNodeIdIndex(id), "PAINTING"); // find the edge index
            replaceString("PAINTING", "NULL", edges[index].pg_modes, 0, edges[index].pg_modes.length); edges[index].pg_mode_counter--;
            // if pg_modes are all NULL, delete the edge
            if (allNullStrings(edges[index].pg_modes)) {
              edges[index].delete(); // delete the edge
              // WHAT ELSE TO DO???
            }
          } 
        } // END FOR EACH OTHER UNIT 
      } // IF PAINTING MODE        
    //if (plot_generation_mode.equals("SCULPTING") && ui.unit_preconditions_counter==0) {satisfied=true;}
        //else if (plot_generation_mode.equals("PAINTING") && ui.unit_preconditions_counter==0) {satisfied=false;}
        //if (satisfied && search_edge_head_tail_index(i, searchNodeIdIndex(id))==-1) {           
        //  // println("unit "+i+".unit_effects["+is+"] = " + ui.unit_effects[is]); println("unit "+j+".unit_preconditions["+js+"] = " + uj.unit_preconditions[js]); 
        //  edges[i_cur_edge]=new Edge(ui.id, id, "e"+str(i_cur_edge), "NULL", plot_generation_mode); 
        //  i_cur_edge++; 
        //} else
        //if (!satisfied && search_edge_head_tail_index(i, searchNodeIdIndex(id))!=-1) {           
        //  // println("unit "+i+".unit_effects["+is+"] = " + ui.unit_effects[is]); println("unit "+j+".unit_preconditions["+js+"] = " + uj.unit_preconditions[js]); 
        //  edges[search_edge_head_tail_index(i, searchNodeIdIndex(id))].delete(); 
        //}
     // } // END FOR EACH OTHER UNIT
    // } // END IF
  }

  //void show_propp_tag() {
  //  if (plot_generation_mode == "PROPP") {
  //  // println("showing propp tag:"); 
  //  int number_of_items = propp_checkbox.getItems().size();
  //  if (unique_event) {
  //    unique_event=false;
  //    for (int j=0; j<number_of_items; j++) {propp_checkbox.getItem(j).setState(false);} // all items initialized to false
  //    if (unit_propp_tag_index!=-1) {propp_checkbox.getItem(unit_propp_tag_index).setState(true);}
  //    // float bx = check_horizontal_boundaries(x-w/2-(propp_checkbox.getWidth()), propp_checkbox.getWidth());
  //    float bx = check_horizontal_boundaries(x-w/2-propp_checkbox.getWidth(), max_length_propp_id*default_font_width);
  //    //float by = check_vertical_boundaries(y, propp_checkbox.getHeight());
  //    float by = check_vertical_boundaries(y, number_of_items*(default_font_size+spacing_row));
  //    propp_checkbox.setPosition(bx*zoom+xo,by*zoom+yo).show();
  //  }
  //  unique_event = true;
  //  }
  //}
  
  public void show_propp_tag() { // display the Propp tag assigned to the unit
    float bx = x; float by = y; // center coordinates of propp tag box rectangle initially set to unit center
    String propp_tag_box_text = "PROPP_TAG NULL"; if (unit_propp_tag_index!=-1) {propp_tag_box_text = "PROPP TAG "+proppTags[unit_propp_tag_index];}
    String[] words = split_text_into_words (propp_tag_box_text);
    float[] box_size = determine_box_size(words, default_font_aspect_ratio, default_font_size);
    float box_width = box_size[0]; // id_general_length*default_font_width; 
    float box_height = box_size[1]; // 2*default_font_size; // 2 lines TAG \n tag_id
    bx = check_horizontal_boundaries(x+w/2+box_width/2, box_width); // display at the right
    by = check_vertical_boundaries(y+box_height/2, box_height); //  display below
    fill(0, 0, 100); //tbackground); WHITE background
    noStroke(); rectMode(CENTER);  
    rect(bx, by, box_width, box_height); 
    write_lines_in_fixed_fontsize(propp_tag_box_text, default_font_name, default_font_aspect_ratio, default_font_size, "LEFT", "TOP", bx, by);
  } // END METHOD show_propp_tag
  
  
  public void modify_propp_tag() {
    unit_propp_tag_index=cur_unit_propp_tag_index;
    if (unit_propp_tag_index!=-1) {x = propp_layout_x[unit_propp_tag_index]/zoom - xo;}
    else {x = (left_offset+diameter_size)/zoom - xo;}
    // hide_all_menus();     
  }

  // unit DRAWING
  public void draw_unit() {    
    // println("Drawing unit " + id); // PRINT CHECK:
    if (!deleted) {
      draw_unit_agents();
      draw_node();
    }
  } // END draw_node

  public void draw_unit_in_nav(String cur_pre_sub) {
    // PRINT CHECK: println("Drawing unit " + id);
    if (!deleted) {
      draw_node_in_nav(cur_pre_sub);
    }
  } // END draw_node

  public void show_agents_and_tag() { // display the agents and the tag over the unit
    // show_tag();
    float bx = x; float by = y; // center coordinates of tag box rectangle initially set to unit center
    String tag_box_text = "TAG "+node_tag; //node_tags[0];
    String[] words = split_text_into_words (tag_box_text);
    float[] box_size = determine_box_size(words, default_font_aspect_ratio, default_font_size);
    float tag_box_width = box_size[0]; // id_general_length*default_font_width; 
    float tag_box_height = box_size[1]; // 2*default_font_size; // 2 lines TAG \n tag_id
    bx = check_horizontal_boundaries(x+w/2+tag_box_width/2, tag_box_width); // display at the right
    by = check_vertical_boundaries(y+tag_box_height/2, tag_box_height); //  display below
    String agents_box_text = "AGENTS "; for (int i=0; i<unit_agents_counter; i++) {agents_box_text = agents_box_text + unit_agents[i] + " ";}
    words = split_text_into_words (agents_box_text);
    box_size = determine_box_size(words, default_font_aspect_ratio, default_font_size);
    float agents_box_width = box_size[0]; // id_general_length*default_font_width; 
    float agents_box_height = box_size[1]; // 2*default_font_size; // 2 lines TAG \n tag_id
    float agt_bx = check_horizontal_boundaries(bx-tag_box_width/2-agents_box_width/2, agents_box_width); // display at the left of the tag
    float agt_by = check_vertical_boundaries(y+agents_box_height/2, agents_box_height); //  display below
    fill(0, 0, 100); //tbackground); WHITE background
    noStroke(); rectMode(CENTER);  
    rect(bx, by, tag_box_width, tag_box_height); 
    write_lines_in_fixed_fontsize(tag_box_text, default_font_name, default_font_aspect_ratio, default_font_size, "LEFT", "TOP", bx, by);
    fill(0, 0, 100); //tbackground); WHITE background
    noStroke(); rectMode(CENTER);  
    rect(agt_bx, agt_by, agents_box_width, agents_box_height); 
    write_lines_in_fixed_fontsize(agents_box_text, default_font_name, default_font_aspect_ratio, default_font_size, "LEFT", "TOP", agt_bx, agt_by);
  } // END METHOD show_agents_and_tag


  public void draw_unit_agents() {
    //println("draw_unit_agents: " + unit_agents_counter);
    if (unit_agents_counter>0) {
      float arc_interval = TWO_PI / unit_agents_counter; 
      for (int i=0; i<unit_agents_counter; i++) {
        Agent a = searchAgent(unit_agents[i]);
        if (a!=null && !a.deleted) {
          stroke(a.agent_color); strokeWeight(margin); // stroke(grey_level); // color: grey filling
          arc(x, y, w+margin, h+margin, i*arc_interval, (i+1)*arc_interval);
        }
      }
    }
  }
  
  public void add_unit_agent(String agt_name) {
    String agt_name_aux = agt_name;
    if (agt_name.equals("NULL")) {
      agt_name_aux = showInputDialog("Please enter agent");
      // if (text_aux == null) exit(); else
      if (agt_name_aux == null || agt_name_aux.equals(""))
        showMessageDialog(null, "Empty input!", "Alert", ERROR_MESSAGE);
      else if (searchStringIndex(agt_name_aux, unit_agents, 0, unit_agents_counter)!=-1)
        showMessageDialog(null, "Agent \"" + agt_name_aux + "\" already in this unit!!!", "Alert", ERROR_MESSAGE);
      else
        showMessageDialog(null, "Agent \"" + agt_name_aux + "\" successfully added to unit!!!", "Info", INFORMATION_MESSAGE);
    }
    if (searchStringIndex(agt_name_aux, unit_agents, 0, unit_agents_counter)==-1) {
      unit_agents[unit_agents_counter++]=agt_name_aux;
      update_agents(agt_name_aux, "ADD");
    }
  }

  public void delete_unit_agent(String agt_name) {
    int agent_index = searchStringIndex(agt_name, unit_agents, 0, unit_agents_counter);
    if (agent_index!=-1) {
      unit_agents = deleteStringByIndex(agent_index, unit_agents);
      unit_agents_counter--;
    } else {showMessageDialog(null, "Agent not in unit!", "Alert", ERROR_MESSAGE);}
  }

  public void modify_agent_name(String old_name, String new_name) {
    replaceString(old_name, new_name, unit_agents, 0, unit_agents_counter);
  }

  public void delete_tension_name() {
    if (unit_tension_name.equals(tensions[i_select_tension].name)) {
      unit_tension_name = "NULL"; // assign NULL
      y = tension_position(50)/zoom-yo; // update unit vertical position with middle position
    } else {showMessageDialog(null, "Different tension selected!", "Alert", ERROR_MESSAGE);}
  }

  public void modify_tension_name(String new_name) {
    unit_tension_name = new_name; // assign new tension name
    Tension t = search_tension(unit_tension_name); // search tension by name
    y = tension_position(t.tension_value)/zoom-yo; // update unit vertical position with tension value
  }

  public void modify_tension_name_from_checkbox() {
    if (cur_unit_tension_index==-1) {unit_tension_name = "NULL";}
    else {unit_tension_name = tensions[cur_unit_tension_index].name;}
    if (!unit_tension_name.equals("NULL")) {
      Tension t = search_tension(unit_tension_name); // search tension by name
      y = tension_position(t.tension_value)/zoom-yo; // update unit vertical position with tension value
    }
    else {y = tension_position(50)/zoom-yo;}
    // hide_all_menus();     
  }

  //void show_tension() {
  //  if (plot_generation_mode == "TENSION") {
  //  // println("showing tension"); 
  //  int number_of_items = tensions_checkbox.getItems().size();
  //  if (unique_event) {
  //    unique_event=false;
  //    for (int j=0; j<number_of_items; j++) {tensions_checkbox.getItem(j).setState(false);} // all items initialized to false
  //    if (!unit_tension_name.equals("NULL")) {
  //      int t_index = search_tension_index(unit_tension_name); 
  //      tensions_checkbox.getItem(t_index).setState(true);
  //    }
  //    //tensions_checkbox.setPosition((x-w/2-tensions_checkbox.getWidth())*zoom+xo,y*zoom+yo).show();
  //    tensions_checkbox.setPosition((x+w/2)*zoom+xo,y*zoom+yo).show();
  //    //float bx = check_horizontal_boundaries(x-(tensions_checkbox.getWidth()+3*default_font_width), tensions_checkbox.getWidth()+3*default_font_width);
  //    //float by = check_vertical_boundaries(y-tensions_checkbox.getHeight(), tensions_checkbox.getHeight());
  //    //tensions_checkbox.setPosition(bx*zoom+xo,by*zoom+yo).show();
  //  }
  //  unique_event = true;
  //  }
  //}

  public void show_tension() { // display the tension assigned to the unit
    float bx = x; float by = y; // center coordinates of tension box rectangle initially set to unit center
    String tension_box_text = "TENSION " + unit_tension_name;
    String[] words = split_text_into_words (tension_box_text);
    float[] box_size = determine_box_size(words, default_font_aspect_ratio, default_font_size);
    float box_width = box_size[0];  
    float box_height = box_size[1]; 
    bx = check_horizontal_boundaries(x+w/2+box_width/2, box_width); // display at the right
    by = check_vertical_boundaries(y+box_height/2, box_height); //  display below
    fill(0, 0, 100); //tbackground); WHITE background
    noStroke(); rectMode(CENTER);  
    rect(bx, by, box_width, box_height); 
    write_lines_in_fixed_fontsize(tension_box_text, default_font_name, default_font_aspect_ratio, default_font_size, "LEFT", "TOP", bx, by);
  } // END METHOD show_tension


} // END UNIT CLASS


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "sketch_Storygraphia_09_7" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
